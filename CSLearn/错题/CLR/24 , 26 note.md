
## 1 . åºåˆ—åŒ–è¿‡ç¨‹è°ƒäº†å“ªäº›APIï¼Œè·å–çš„MemberInfoé‡Œé¢æœ‰ä»€ä¹ˆï¼Ÿ


FormatterServicesçš„ä¸€ä¸ªé™æ€æ–¹æ³•GetSerializableMembers
```cs
   [SecurityCritical] 
public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)
{
    if ((object)type == null)
        throw new ArgumentNullException(nameof(type));

    MemberHolder key = (object)(type as RuntimeType) != null
        ? new MemberHolder(type, context)  // å¦‚æœæ˜¯ RuntimeTypeï¼Œåˆ›å»ºä¸€ä¸ª MemberHolder å¯¹è±¡ï¼Œä½œä¸ºå­—å…¸çš„é”®
        : throw new SerializationException(Environment.GetResourceString("Serialization_InvalidType", (object)type.ToString()));

    // è·å–æˆ–æ·»åŠ ç±»å‹çš„åºåˆ—åŒ–æˆå‘˜ä¿¡æ¯
    return FormatterServices.m_MemberInfoTable.GetOrAdd(key, (Func<MemberHolder, MemberInfo[]>)(_ => FormatterServices.InternalGetSerializableMembers((RuntimeType)type)));
}

private static MemberInfo[] InternalGetSerializableMembers(RuntimeType type)
{
    if (type.IsInterface)
        return new MemberInfo[0];
    
    // æ£€æŸ¥ç±»å‹æ˜¯å¦æ˜¯å¯åºåˆ—åŒ–çš„ï¼Œå¦‚æœä¸å¯åºåˆ—åŒ–ï¼ŒæŠ›å‡º SerializationException å¼‚å¸¸
    MemberInfo[] sourceArray = FormatterServices.CheckSerializable(type)
        ? FormatterServices.GetSerializableMembers(type)  // å¦‚æœæ˜¯å¯åºåˆ—åŒ–çš„ï¼Œè·å–å®ƒçš„åºåˆ—åŒ–æˆå‘˜
        : throw new SerializationException(Environment.GetResourceString("Serialization_NonSerType", (object)type.FullName, (object)type.Module.Assembly.FullName));

    // è·å–ç±»å‹çš„åŸºç±»å‹ï¼ˆçˆ¶ç±»ï¼‰
    RuntimeType baseType = (RuntimeType)type.BaseType;
    
    // å¦‚æœçˆ¶ç±»å­˜åœ¨å¹¶ä¸”ä¸æ˜¯ Object ç±»å‹ï¼Œåˆ™ç»§ç»­å¤„ç†çˆ¶ç±»çš„åºåˆ—åŒ–æˆå‘˜
    if (baseType != (RuntimeType)null && baseType != (RuntimeType)typeof(object))
    {
        RuntimeType[] parentTypes1 = null;
        int parentTypeCount = 0;
        
        // è·å–çˆ¶ç±»çš„ç±»å‹æ•°ç»„
        bool parentTypes2 = FormatterServices.GetParentTypes(baseType, out parentTypes1, out parentTypeCount);
        
        if (parentTypeCount > 0)
        {
            List<SerializationFieldInfo> serializationFieldInfoList = new List<SerializationFieldInfo>();
            
            // éå†æ¯ä¸ªçˆ¶ç±»ï¼Œè·å–å®ƒä»¬çš„åºåˆ—åŒ–å­—æ®µ
            for (int index = 0; index < parentTypeCount; ++index)
            {
                RuntimeType type1 = parentTypes1[index];
                
                // æ£€æŸ¥çˆ¶ç±»æ˜¯å¦æ˜¯å¯åºåˆ—åŒ–çš„ï¼Œè·å–å®ƒçš„å®ä¾‹å­—æ®µï¼ˆåŒ…æ‹¬ç§æœ‰å­—æ®µï¼‰
                FieldInfo[] fieldInfoArray = FormatterServices.CheckSerializable(type1)
                    ? type1.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)
                    : throw new SerializationException(Environment.GetResourceString("Serialization_NonSerType", (object)type1.FullName, (object)type1.Module.Assembly.FullName));
                
                // ç”Ÿæˆçˆ¶ç±»åç§°çš„å‰ç¼€ï¼Œç”¨äºå­—æ®µåç§°çš„å‰ç¼€
                string namePrefix = parentTypes2 ? type1.Name : type1.FullName;
                
                // éå†å­—æ®µï¼Œæ‰¾åˆ°æ‰€æœ‰éœ€è¦åºåˆ—åŒ–çš„å­—æ®µï¼ˆä¸åŒ…æ‹¬ [NonSerialized] ç‰¹æ€§æ ‡è®°çš„å­—æ®µï¼‰
                foreach (FieldInfo field in fieldInfoArray)
                {
                    if (!field.IsNotSerialized) // åˆ¤æ–­å­—æ®µæ˜¯å¦ä¸éœ€è¦åºåˆ—åŒ–
                        serializationFieldInfoList.Add(new SerializationFieldInfo((RuntimeFieldInfo)field, namePrefix));
                }
            }
            
            // å¦‚æœæ‰¾åˆ°éœ€è¦åºåˆ—åŒ–çš„å­—æ®µï¼Œåˆå¹¶å®ƒä»¬åˆ°è¿”å›çš„åºåˆ—åŒ–æˆå‘˜æ•°ç»„ä¸­
            if (serializationFieldInfoList != null && serializationFieldInfoList.Count > 0)
            {
                MemberInfo[] destinationArray = new MemberInfo[serializationFieldInfoList.Count + sourceArray.Length];
                
                // å¤åˆ¶å½“å‰ç±»å‹çš„åºåˆ—åŒ–æˆå‘˜åˆ°ç›®æ ‡æ•°ç»„
                Array.Copy((Array)sourceArray, (Array)destinationArray, sourceArray.Length);
                
                // å°†çˆ¶ç±»çš„åºåˆ—åŒ–å­—æ®µä¿¡æ¯å¤åˆ¶åˆ°ç›®æ ‡æ•°ç»„
                ((ICollection)serializationFieldInfoList).CopyTo((Array)destinationArray, sourceArray.Length);
                
                // æ›´æ–°æºæ•°ç»„ä¸ºåˆå¹¶åçš„æ•°ç»„
                sourceArray = destinationArray;
            }
        }
    }

    // è¿”å›æœ€ç»ˆçš„åºåˆ—åŒ–æˆå‘˜ä¿¡æ¯
    return sourceArray;
}

private static MemberInfo[] GetSerializableMembers(RuntimeType type)
{
    // è·å–å½“å‰ç±»å‹çš„æ‰€æœ‰å­—æ®µï¼ˆåŒ…æ‹¬ç§æœ‰ï¼Œä¿æŠ¤å­—æ®µã€å…¬å…±å­—æ®µï¼‰
    FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
    int length = 0;
    
    // ç»Ÿè®¡éœ€è¦åºåˆ—åŒ–çš„å­—æ®µæ•°é‡ï¼ˆæ’é™¤ [NonSerialized] ç‰¹æ€§æ ‡è®°çš„å­—æ®µï¼‰
    for (int index = 0; index < fields.Length; ++index)
    {
        if ((fields[index].Attributes & FieldAttributes.NotSerialized) != FieldAttributes.NotSerialized)
            ++length;
    }
    
    // å¦‚æœæ‰€æœ‰å­—æ®µéƒ½éœ€è¦åºåˆ—åŒ–ï¼Œç›´æ¥è¿”å›å­—æ®µæ•°ç»„
    if (length == fields.Length)
        return (MemberInfo[])fields;
    
    // å¦åˆ™ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ç”¨äºå­˜å‚¨å¯åºåˆ—åŒ–çš„å­—æ®µ
    FieldInfo[] serializableMembers = new FieldInfo[length];
    int index1 = 0;
    
    // å°†éœ€è¦åºåˆ—åŒ–çš„å­—æ®µå¤åˆ¶åˆ°æ–°çš„æ•°ç»„ä¸­
    for (int index2 = 0; index2 < fields.Length; ++index2)
    {
        if ((fields[index2].Attributes & FieldAttributes.NotSerialized) != FieldAttributes.NotSerialized)
        {
            serializableMembers[index1] = fields[index2];
            ++index1;
        }
    }
    
    // è¿”å›è¿‡æ»¤åçš„å¯åºåˆ—åŒ–å­—æ®µæ•°ç»„
    return (MemberInfo[])serializableMembers;
}
```

è¿™ä¸ªæ–¹æ³•è·å–çš„MemberInfo[] é‡Œé¢æ˜¯ fileInfoå®ä¾‹ï¼Œå¤„ç†å¼•ç”¨å­—æ®µæ˜¯åœ¨ObjectWriterå¤„ç†çš„ã€‚

## 2. äº‹ä»¶æˆå‘˜ï¼Œ+= ååºåˆ—åŒ–ä¼šæ€ä¹ˆæ ·

```cs
[Serializable]
    class Test
    {
        public event Action<int> callBack; //äº‹ä»¶æˆå‘˜

        public void Call(int i)
        {
            callBack?.Invoke(i);
        }
    }

    [Serializable]
    class Test2
    {
        public void TestInstance(int i) // æ·»åŠ è¿›å§”æ‰˜é“¾çš„å®ä¾‹æ–¹æ³•
        {
            Console.WriteLine(i + " " + this);
        }
    }

    internal class Program
    {
        public static void Main(string[] args)
        {
            Test test = new Test();
            Test2 test2 = new Test2();
            test.callBack += test2.TestInstance;
            test.callBack += test2.TestInstance;
            // test.Call(1);

            BinaryFormatter binaryFormatter = new BinaryFormatter();
            var memoryStream = new System.IO.MemoryStream();
            binaryFormatter.Serialize(memoryStream, test);
            memoryStream.Position = 0;
            var deserialize = binaryFormatter.Deserialize(memoryStream) as Test;
            deserialize.Call(1);
        }
    }

// è¾“å‡ºå¦‚ä¸‹ï¼š
// 1 TestEventSer.Test2
// 1 TestEventSer.Test2

```

æŸ¥çœ‹åºåˆ—åŒ–åçš„å†…å®¹å¦‚ä¸‹ï¼š
```
    ï£µï£µï£µï£µ          CTestEventSer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null   TestEventSer.Test   callBack"System.DelegateSerializationHolder   	      "System.DelegateSerializationHolder   Delegatetarget0method0target1method10System.DelegateSerializationHolder+DelegateEntryTestEventSer.Test2   /System.Reflection.MemberInfoSerializationHolderTestEventSer.Test2   /System.Reflection.MemberInfoSerializationHolder	   	   	   	   	      0System.DelegateSerializationHolder+DelegateEntry   typeassemblytargettargetTypeAssemblytargetTypeName
methodName
delegateEntry0System.DelegateSerializationHolder+DelegateEntry	   lSystem.Action`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]
   Kmscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089   target0   CTestEventSer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
   TestEventSer.Test2   TestInstance	      TestEventSer.Test2          /System.Reflection.MemberInfoSerializationHolder   NameAssemblyName	ClassName	Signature
Signature2
MemberTypeGenericArguments 
System.Type[]	   	   	
      Void TestInstance(Int32)   &System.Void TestInstance(System.Int32)   
      		   	
      target1	   	
   	   

```

æµ‹è¯•åºåˆ—åŒ– ä¸€ä¸ª Action<\int> å®ä¾‹
```cs
  [Serializable]
    class Test2
    {
        public void TestInstance(int i)
        {
            Console.WriteLine(i + " " + this);
        }
    }

    internal class Program
    {
        public static void Main(string[] args)
        {
            // var test = new Test();
            var test2 = new Test2();
            // test.callBack += test2.TestInstance;
            // test.callBack += test2.TestInstance;
            // test.Call(1);
            Action<int> action = test2.TestInstance;

            var binaryFormatter = new BinaryFormatter();
            var stream = new FileStream("data.txt", FileMode.Create);

            binaryFormatter.Serialize(stream, action);
            stream.Position = 0;
            // stream.Close();
            var deserialize = binaryFormatter.Deserialize(stream) as Action<int>;
            deserialize.Invoke(1);
            // deserialize.Call(1);
        }
    }
```

æŸ¥çœ‹åºåˆ—åŒ–å‡ºæ¥çš„ä¸œè¥¿
```
    ï£µï£µï£µï£µ          CTestEventSer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null   "System.DelegateSerializationHolder   Delegatetarget0method00System.DelegateSerializationHolder+DelegateEntryTestEventSer.Test2   /System.Reflection.MemberInfoSerializationHolder	   	   	      0System.DelegateSerializationHolder+DelegateEntry   typeassemblytargettargetTypeAssemblytargetTypeName
methodName
delegateEntry0System.DelegateSerializationHolder+DelegateEntry   lSystem.Action`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]   Kmscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089   target0	   CTestEventSer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
   TestEventSer.Test2   TestInstance
   TestEventSer.Test2          /System.Reflection.MemberInfoSerializationHolder   NameAssemblyName	ClassName	Signature
Signature2
MemberTypeGenericArguments 
System.Type[]	   		   	
      Void TestInstance(Int32)   &System.Void TestInstance(System.Int32)   

```

åºåˆ—åŒ–äº‹ä»¶ç›¸å½“äºåºåˆ—åŒ–äº‹ä»¶ç”Ÿæˆçš„å§”æ‰˜å­—æ®µï¼Œå§”æ‰˜æœ¬èº«å°±æ˜¯å¯åºåˆ—åŒ–çš„ï¼ˆ_target, _methodPtr, _invocationList ...éƒ½è¢«åºåˆ—åŒ–ï¼‰
## 3. ååºåˆ—åŒ–æµç¨‹å¦‚ä½•è·å–MemberInfo

>1. æ ¼å¼åŒ–å™¨ä»æµä¸­è¯»å–ç¨‹åºé›†æ ‡è¯†å’Œå®Œæ•´ç±»å‹åç§°ã€‚å¦‚æœç¨‹åºé›†å½“å‰æ²¡æœ‰åŠ è½½åˆ° AppDomain ä¸­ï¼Œå°±åŠ è½½å®ƒ(è¿™ä¸€ç‚¹å‰é¢å·²ç»è®²è¿‡äº†)ã€‚å¦‚æœç¨‹åºé›†ä¸èƒ½åŠ è½½ï¼Œå°±æŠ›å‡ºä¸€ä¸ª `SerializationException` å¼‚å¸¸ï¼Œå¯¹è±¡ä¸èƒ½ååºåˆ—åŒ–ã€‚å¦‚æœç¨‹åºé›†å·²åŠ è½½ï¼Œæ ¼å¼åŒ–å™¨å°†ç¨‹åºé›†æ ‡è¯†ä¿¡æ¯å’Œç±»å‹å…¨åä¼ ç»™ `FormatterServices` çš„é™æ€æ–¹æ³• `GetTypeFromAssembly`:  
  `public static Type GetTypeFromAssembly(Assembly assem, String name);`  
  è¿™ä¸ªæ–¹æ³•è¿”å›ä¸€ä¸ª `System.Type` å¯¹è±¡ï¼Œå®ƒä»£è¡¨è¦ååºåˆ—åŒ–çš„é‚£ä¸ªå¯¹è±¡çš„ç±»å‹ã€‚
>
>2. æ ¼å¼åŒ–å™¨è°ƒç”¨ `FormmatterServices` çš„é™æ€æ–¹æ³• `GetUninitializedObject`:  
   `public static Object GetUninitializedObject(Type type);`  
   è¿™ä¸ªæ–¹æ³•ä¸ºä¸€ä¸ªæ–°å¯¹è±¡åˆ†é…å†…å­˜ï¼Œä½†ä¸ä¸ºå¯¹è±¡è°ƒç”¨æ„é€ å™¨ã€‚ç„¶è€Œï¼Œå¯¹è±¡çš„æ‰€æœ‰å­—èŠ‚éƒ½è¢«åˆå§‹ä¸º `null` æˆ– `0`ã€‚
>
>3. æ ¼å¼åŒ–å™¨ç°åœ¨æ„é€ å¹¶åˆå§‹åŒ–ä¸€ä¸ª `MemberInfo` æ•°ç»„ï¼Œå…·ä½“åšæ³•å’Œå‰é¢ä¸€æ ·ï¼Œéƒ½æ˜¯è°ƒç”¨ `FormatterServices` çš„ `GetSerializableMembers` æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›åºåˆ—åŒ–å¥½ã€ç°åœ¨éœ€è¦ååºåˆ—åŒ–çš„ä¸€ç»„å­—æ®µã€‚
>
>4. æ ¼å¼åŒ–å™¨æ ¹æ®æµä¸­åŒ…å«çš„æ•°æ®åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ª `Object` æ•°ç»„ã€‚
>
>5. å°†æ–°åˆ†é…å¯¹è±¡ã€`MemberInfo` æ•°ç»„ä»¥åŠå¹¶è¡Œ `Object` æ•°ç»„(å…¶ä¸­åŒ…å«å­—æ®µå€¼)çš„å¼•ç”¨ä¼ ç»™ `FormatterServices` çš„é™æ€æ–¹æ³• `PopulateObjectMembers`ï¼š  
  `public static Object PopulateObjectMembers(Object obj, MemberInfo[] members, Object[] data);`  
   è¿™ä¸ªæ–¹æ³•éå†æ•°ç»„ï¼Œå°†æ¯ä¸ªå­—æ®µåˆå§‹åŒ–æˆå¯¹åº”çš„å€¼ã€‚åˆ°æ­¤ä¸ºæ­¢ï¼Œå¯¹è±¡å°±ç®—æ˜¯è¢«å½»åº•ååºåˆ—åŒ–äº†ã€‚
## 4. ISerializableï¼Œåºåˆ—åŒ–æ•°ç»„æ€ä¹ˆåš

```cs
  [Serializable]
    internal class Test : ISerializable
    {
        private Test2 test2;
        Test2[] list = new Test2[3]; // æ•°ç»„å­—æ®µ

        public Test()
        {
            test2 = new Test2();
            list[0] = new Test2();
            list[1] = new Test2();
            list[2] = new Test2();
        }

        private Test(SerializationInfo info, StreamingContext context)
        {
            test2 = (Test2)info.GetValue("test2", typeof(Test2));
            list = (Test2[])info.GetValue("list", typeof(Test2[]));
        }

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue("test2", test2);
            info.AddValue("list", list); // ç›´æ¥æ·»åŠ è¿›å»ï¼Œåºåˆ—åŒ–å™¨æ˜¯æ”¯æŒå¤„ç†çš„
        }

        public override string ToString()
        {
            string s = "test2: " + test2 + "\n";
            s += "list: ";
            foreach (Test2 t in list)
            {
                s += t + " ";
            }

            return s;
        }
    }

    [Serializable]
    internal class Test2
    {
    }

    internal class Program
    {
        public static void Main(string[] args)
        {
            Test t = new Test();
            BinaryFormatter bf = new BinaryFormatter();
            using (FileStream fs = new FileStream("test.dat", FileMode.Create))
            {
                bf.Serialize(fs, t);
                fs.Position = 0;
                Test t2 = (Test)bf.Deserialize(fs);
                Console.Write(t2);
            }
        }
    }
```

æŸ¥çœ‹åºåˆ—åŒ–æµçš„å†…å®¹å¦‚ä¸‹ï¼š
```
    ï£µï£µï£µï£µ          BTestSerList, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null   TestSerList.Test   test2listTestSerList.Test2   TestSerList.Test2[]      	   	      TestSerList.Test2                 TestSerList.Test2   	   	   	                     
```

## 5. åºåˆ—åŒ–æˆä¸€ä¸ªç±»å‹ï¼Œååºåˆ—åŒ–æˆä¸åŒç±»å‹æ€ä¹ˆåšï¼Ÿ


ä½¿ç”¨binderçš„æ–¹å¼
```cs
internal static class SerializationBinderDemo
{
    public static void Go()
    {
        using (var stream = new MemoryStream())
        {
            IFormatter formatter = new BinaryFormatter();
            formatter.Binder = new Ver1ToVer2SerializationBinder();
            formatter.Serialize(stream, new Ver1());

            stream.Position = 0;
            object t = formatter.Deserialize(stream);
            Console.WriteLine("Type deserialized={0}, ToString={{{1}}}", t.GetType(), t);
        }
    }

    [Serializable]
    private sealed class Ver1
    {
        public Int32 x = 1, y = 2, z = 3;
    }

    [Serializable]
    private sealed class Ver2 : ISerializable
    {
        Int32 a, b, c;

        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
        }

        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        private Ver2(SerializationInfo info, StreamingContext context)
        {
            a = info.GetInt32("x");
            b = info.GetInt32("y");
            c = info.GetInt32("z");
        }

        public override string ToString()
        {
            return $"a={a.ToString()}, b={b.ToString()}, c={c.ToString()}";
        }
    }

    private sealed class Ver1ToVer2SerializationBinder : SerializationBinder
    {
        public override Type BindToType(String assemblyName, String typeName)
        {
            AssemblyName assemVer1 = Assembly.GetExecutingAssembly().GetName();
            assemVer1.Version = new Version(1, 0, 0, 0);

            if (assemblyName == assemVer1.ToString() && typeName == "SerializationBinderDemo+Ver1")
                return typeof(Ver2);

            return Type.GetType(String.Format("{0}, {1}", typeName, assemblyName));
        }
    }
}
```

## 6. æ ¼å¼åŒ–å™¨ï¼Œä»£ç†ç©¶ç«Ÿå¹²äº†å•¥ã€‚

>
>æ­¥éª¤ 1 åˆ°æ­¥éª¤ 4 æ‰§è¡Œå®Œæ¯•åï¼Œæ ¼å¼åŒ–å™¨å°±å‡†å¤‡å¥½ä½¿ç”¨å·²ç™»è®°çš„ä»£ç†ç±»å‹ã€‚è°ƒç”¨æ ¼å¼åŒ–å™¨çš„ `Serialize` æ–¹æ³•æ—¶ï¼Œä¼šåœ¨ `SurrogateSelector` ç»´æŠ¤çš„é›†åˆ(ä¸€ä¸ªå“ˆå¸Œè¡¨)ä¸­æŸ¥æ‰¾(è¦åºåˆ—åŒ–çš„)æ¯ä¸ªå¯¹è±¡çš„ç±»å‹ã€‚å¦‚æœå‘ç°ä¸€ä¸ªåŒ¹é…ï¼Œå°±è°ƒç”¨ `ISerializationSurrogate` å¯¹è±¡çš„ `GetObjectData` æ–¹æ³•æ¥è·å–åº”è¯¥å†™å…¥æµçš„ä¿¡æ¯ã€‚
>
>æ ¼å¼åŒ–å™¨çš„ `Deserialize` æ–¹æ³•åœ¨è°ƒç”¨æ—¶ï¼Œä¼šåœ¨æ ¼å¼åŒ–å™¨çš„ `SurrogateSelector` ä¸­æŸ¥æ‰¾è¦ååºåˆ—åŒ–çš„å¯¹è±¡çš„ç±»å‹ã€‚å¦‚æœå‘ç°ä¸€ä¸ªåŒ¹é…ï¼Œå°±è°ƒç”¨`ISerializationSurrogate` å¯¹è±¡çš„ `SetObjectData` æ–¹æ³•æ¥è®¾ç½®è¦ååºåˆ—åŒ–çš„å¯¹è±¡ä¸­çš„å­—æ®µã€‚
>
>`SurrogateSelector` å¯¹è±¡åœ¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªç§æœ‰å“ˆå¸Œè¡¨ã€‚è°ƒç”¨ `AddSurrogate` æ—¶ï¼Œ`Type` å’Œ `StreamingContext` æ„æˆäº†å“ˆå¸Œè¡¨çš„é”®(key)ï¼Œå¯¹åº”çš„å€¼(value)å°±æ˜¯ `ISerializationSurrogate` å¯¹è±¡ã€‚å¦‚æœå·²ç»å­˜åœ¨å’Œè¦æ·»åŠ çš„ `Type/StreamingContext` ç›¸åŒçš„ä¸€ä¸ªé”®ï¼Œ`AddSurrogate` ä¼šæŠ›å‡ºä¸€ä¸ª `ArgumentException`ã€‚é€šè¿‡åœ¨é”®ä¸­åŒ…å«ä¸€ä¸ª `StreamingContext`ï¼Œå¯ä»¥ç™»è®°ä¸€ä¸ªä»£ç†ç±»å‹å¯¹è±¡ï¼Œå®ƒçŸ¥é“å¦‚ä½•å°† `DateTime` å¯¹è±¡åºåˆ—åŒ–/ååºåˆ—åŒ–åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼›å†ç™»è®°ä¸€ä¸ªä¸åŒçš„ä»£ç†å¯¹è±¡ï¼Œå®ƒçŸ¥é“å¦‚ä½•å°† `DateTime` å¯¹è±¡åºåˆ—åŒ–ã€ååºåˆ—åŒ–åˆ°ä¸€ä¸ªä¸åŒçš„è¿›ç¨‹ä¸­ã€‚

## 7. è¿›ç¨‹èƒ½è¿›è¡Œå†…æ ¸æ€å—ï¼Ÿ

[ç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼ - Windows é©±åŠ¨ç¨‹åº | Microsoft Learn --- User Mode and Kernel Mode - Windows drivers | Microsoft Learn](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode)
>A processor in a computer running Windows operates in two different modes:Â _user mode_Â andÂ _kernel mode_. The processor switches between these modes depending on the type of code it's executing. Applications operate in user mode, while core operating system components function in kernel mode. Although many drivers operate in kernel mode, some can function in user mode.

ä¸¤ç§æ¨¡å¼è¯´çš„æ˜¯CPUçš„æ‰§è¡Œæ¨¡å¼ã€‚

## 8. çº¿ç¨‹ç¯å¢ƒå—æœ‰ä»€ä¹ˆï¼Œä»€ä¹ˆç”¨ï¼ŒDLLçº¿ç¨‹è¿æ¥å’Œçº¿ç¨‹åˆ†ç¦»é€šçŸ¥...

>
>* **çº¿ç¨‹ç¯å¢ƒå—(thread environment blockï¼ŒTEB)**  
  TEB æ˜¯åœ¨ç”¨æˆ·æ¨¡å¼(åº”ç”¨ç¨‹åºä»£ç èƒ½å¿«é€Ÿè®¿é—®çš„åœ°å€ç©ºé—´)ä¸­åˆ†é…å’Œåˆå§‹åŒ–çš„å†…å­˜å—ã€‚
  >
 > TEB è€—ç”¨ 1 ä¸ªå†…å­˜é¡µ(x86ï¼Œ x64 å’Œ ARM CPU ä¸­æ˜¯ 4 KB)ã€‚ 
  TEB åŒ…å«çº¿ç¨‹çš„å¼‚å¸¸å¤„ç†é“¾é¦–(head)ã€‚çº¿ç¨‹è¿›å…¥çš„æ¯ä¸ª `try` å—éƒ½åœ¨é“¾é¦–æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹(node)ï¼›çº¿ç¨‹é€€å‡º `try` å—æ—¶ä»é“¾ä¸­åˆ é™¤è¯¥èŠ‚ç‚¹ã€‚
  >
  >æ­¤å¤–ï¼ŒTEB è¿˜åŒ…å«çº¿ç¨‹çš„â€œçº¿ç¨‹æœ¬åœ°å­˜å‚¨â€æ•°æ®ï¼Œä»¥åŠç”± GDI(Graphics Deveice Interfaceï¼Œ å›¾å½¢è®¾å¤‡æ¥å£)å’Œ OpenGL å›¾å½¢ä½¿ç”¨çš„ä¸€äº›æ•°æ®ç»“æ„ã€‚
>
>
>* **DLL çº¿ç¨‹è¿æ¥(attach)å’Œçº¿ç¨‹åˆ†ç¦»(detach)é€šçŸ¥**  
  Windows çš„ä¸€ä¸ªç­–ç•¥æ˜¯ï¼Œä»»ä½•æ—¶å€™åœ¨è¿›ç¨‹ä¸­åˆ›å»ºçº¿ç¨‹ï¼Œéƒ½ä¼šè°ƒç”¨è¿›ç¨‹ä¸­åŠ è½½çš„æ‰€æœ‰éæ‰˜ç®¡ DLL çš„ `DllMain` æ–¹æ³•ï¼Œå¹¶å‘è¯¥æ–¹æ³•ä¼ é€’ `DLL_THREAD_ATTACH` æ ‡å¿—ã€‚
  ç±»ä¼¼åœ°ï¼Œä»»ä½•æ—¶å€™çº¿ç¨‹ç»ˆæ­¢ï¼Œéƒ½ä¼šè°ƒç”¨è¿›ç¨‹ä¸­çš„æ‰€æœ‰éæ‰˜ç®¡ DLL çš„ `DLLMain` æ–¹æ³•ï¼Œå¹¶å‘æ–¹æ³•ä¼ é€’`DLL_THREAD_DETACH` æ ‡å¿—ã€‚
  >
  >æœ‰çš„ DLL éœ€è¦è·å–è¿™äº›é€šçŸ¥ï¼Œæ‰èƒ½ä¸ºè¿›ç¨‹ä¸­åˆ›å»º/é”€æ¯çš„æ¯ä¸ªçº¿ç¨‹æ‰§è¡Œç‰¹æ®Šçš„åˆå§‹åŒ–æˆ–(èµ„æº)æ¸…ç†æ“ä½œã€‚ä¾‹å¦‚ï¼Œ C-Runtime åº“ DLL ä¼šåˆ†é…ä¸€äº›çº¿ç¨‹æœ¬åœ°å­˜å‚¨çŠ¶æ€ã€‚çº¿ç¨‹ä½¿ç”¨ C-Runtime åº“ä¸­åŒ…å«çš„å‡½æ•°æ—¶éœ€è¦ç”¨åˆ°è¿™äº›çŠ¶æ€ã€‚

## 9 åˆ‡æ¢çº¿ç¨‹åšäº†å•¥


>1. å°† `CPU` å¯„å­˜å™¨çš„å€¼ä¿å­˜åˆ°å½“å‰æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹çš„å†…æ ¸å¯¹è±¡å†…éƒ¨çš„ä¸€ä¸ªä¸Šä¸‹æ–‡ç»“æ„ä¸­ã€‚
>
>2. ä»ç°æœ‰çº¿ç¨‹é›†åˆä¸­é€‰å‡ºä¸€ä¸ªçº¿ç¨‹ä¾›è°ƒåº¦ã€‚å¦‚æœè¯¥çº¿ç¨‹ç”±å¦ä¸€ä¸ªè¿›ç¨‹æ‹¥æœ‰ï¼ŒWindows åœ¨å¼€å§‹æ‰§è¡Œä»»ä½•ä»£ç æˆ–è€…æ¥è§¦ä»»ä½•æ•°æ®ä¹‹å‰ï¼Œè¿˜å¿…é¡»åˆ‡æ¢ CPU â€œçœ‹è§â€ çš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚
>
>3. å°†æ‰€é€‰ä¸Šä¸‹æ–‡ç»“æ„ä¸­çš„å€¼åŠ è½½åˆ° `CPU` çš„å¯„å­˜å™¨ä¸­ã€‚
>
>ä¸Šä¸‹æ–‡åˆ‡æ¢å®Œæˆåï¼ŒCPU æ‰§è¡Œæ‰€é€‰çš„çº¿ç¨‹ï¼Œç›´åˆ°å®ƒçš„æ—¶é—´ç‰‡åˆ°æœŸã€‚
