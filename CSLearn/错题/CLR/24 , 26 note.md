
## 1 . 序列化过程调了哪些API，获取的MemberInfo里面有什么？


FormatterServices的一个静态方法GetSerializableMembers
```cs

   [SecurityCritical] 
public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)
{
    if ((object)type == null)
        throw new ArgumentNullException(nameof(type));

    MemberHolder key = (object)(type as RuntimeType) != null
        ? new MemberHolder(type, context)  // 如果是 RuntimeType，创建一个 MemberHolder 对象，作为字典的键
        : throw new SerializationException(Environment.GetResourceString("Serialization_InvalidType", (object)type.ToString()));

    // 获取或添加类型的序列化成员信息
    return FormatterServices.m_MemberInfoTable.GetOrAdd(key, (Func<MemberHolder, MemberInfo[]>)(_ => FormatterServices.InternalGetSerializableMembers((RuntimeType)type)));
}

private static MemberInfo[] InternalGetSerializableMembers(RuntimeType type)
{
    if (type.IsInterface)
        return new MemberInfo[0];
    
    // 检查类型是否是可序列化的，如果不可序列化，抛出 SerializationException 异常
    MemberInfo[] sourceArray = FormatterServices.CheckSerializable(type)
        ? FormatterServices.GetSerializableMembers(type)  // 如果是可序列化的，获取它的序列化成员
        : throw new SerializationException(Environment.GetResourceString("Serialization_NonSerType", (object)type.FullName, (object)type.Module.Assembly.FullName));

    // 获取类型的基类型（父类）
    RuntimeType baseType = (RuntimeType)type.BaseType;
    
    // 如果父类存在并且不是 Object 类型，则继续处理父类的序列化成员
    if (baseType != (RuntimeType)null && baseType != (RuntimeType)typeof(object))
    {
        RuntimeType[] parentTypes1 = null;
        int parentTypeCount = 0;
        
        // 获取父类的类型数组
        bool parentTypes2 = FormatterServices.GetParentTypes(baseType, out parentTypes1, out parentTypeCount);
        
        if (parentTypeCount > 0)
        {
            List<SerializationFieldInfo> serializationFieldInfoList = new List<SerializationFieldInfo>();
            
            // 遍历每个父类，获取它们的序列化字段
            for (int index = 0; index < parentTypeCount; ++index)
            {
                RuntimeType type1 = parentTypes1[index];
                
                // 检查父类是否是可序列化的，获取它的实例字段（包括私有字段）
                FieldInfo[] fieldInfoArray = FormatterServices.CheckSerializable(type1)
                    ? type1.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)
                    : throw new SerializationException(Environment.GetResourceString("Serialization_NonSerType", (object)type1.FullName, (object)type1.Module.Assembly.FullName));
                
                // 生成父类名称的前缀，用于字段名称的前缀
                string namePrefix = parentTypes2 ? type1.Name : type1.FullName;
                
                // 遍历字段，找到所有需要序列化的字段（不包括 [NonSerialized] 特性标记的字段）
                foreach (FieldInfo field in fieldInfoArray)
                {
                    if (!field.IsNotSerialized) // 判断字段是否不需要序列化
                        serializationFieldInfoList.Add(new SerializationFieldInfo((RuntimeFieldInfo)field, namePrefix));
                }
            }
            
            // 如果找到需要序列化的字段，合并它们到返回的序列化成员数组中
            if (serializationFieldInfoList != null && serializationFieldInfoList.Count > 0)
            {
                MemberInfo[] destinationArray = new MemberInfo[serializationFieldInfoList.Count + sourceArray.Length];
                
                // 复制当前类型的序列化成员到目标数组
                Array.Copy((Array)sourceArray, (Array)destinationArray, sourceArray.Length);
                
                // 将父类的序列化字段信息复制到目标数组
                ((ICollection)serializationFieldInfoList).CopyTo((Array)destinationArray, sourceArray.Length);
                
                // 更新源数组为合并后的数组
                sourceArray = destinationArray;
            }
        }
    }

    // 返回最终的序列化成员信息
    return sourceArray;
}

private static MemberInfo[] GetSerializableMembers(RuntimeType type)
{
    // 获取当前类型的所有字段（包括私有，保护字段、公共字段）
    FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
    int length = 0;
    
    // 统计需要序列化的字段数量（排除 [NonSerialized] 特性标记的字段）
    for (int index = 0; index < fields.Length; ++index)
    {
        if ((fields[index].Attributes & FieldAttributes.NotSerialized) != FieldAttributes.NotSerialized)
            ++length;
    }
    
    // 如果所有字段都需要序列化，直接返回字段数组
    if (length == fields.Length)
        return (MemberInfo[])fields;
    
    // 否则，创建一个新的数组用于存储可序列化的字段
    FieldInfo[] serializableMembers = new FieldInfo[length];
    int index1 = 0;
    
    // 将需要序列化的字段复制到新的数组中
    for (int index2 = 0; index2 < fields.Length; ++index2)
    {
        if ((fields[index2].Attributes & FieldAttributes.NotSerialized) != FieldAttributes.NotSerialized)
        {
            serializableMembers[index1] = fields[index2];
            ++index1;
        }
    }
    
    // 返回过滤后的可序列化字段数组
    return (MemberInfo[])serializableMembers;
}


```


## 2. 事件成员，+= 后序列化会怎么样

## 3. 反序列化流程如何获取MemberInfo

## 4. ISerializable，序列化数组怎么做

## 5. 序列化成一个类型，反序列化成不同类型怎么做？

## 6. 格式化器，代理究竟干了啥。

## 7. 进程能进行内核态吗？

## 8. 线程环境块有什么，什么用，DLL线程连接和线程分离通知...

## 9 切换线程做了啥（分情况讨论）

## 线程内核对象是啥？