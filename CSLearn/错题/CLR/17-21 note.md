## 1. lambdaè¡¨è¾¾å¼ç”Ÿæˆç±»çš„æƒ…å†µè®¨è®ºï¼Œé™æ€ | å®ä¾‹ï¼Œä¸€ä¸ªæ–¹æ³•å†…æœ‰å¤šä¸ªlambdaè¡¨è¾¾å¼C#ç¼–è¯‘å™¨ä¼šæ€ä¹ˆå¤„ç†

```cs
internal class Program
{
	public static void Main(string[] args)
	{
		Func<int, int, int> ac1 = (a, b) => { return a + b; };
		Func<int, int, int, int> ac2 = (a, b, c) => { return a + b + c; };

		Console.WriteLine(ac1(10, 12));
		Console.WriteLine(ac2(10, 12, 14));
	}
}
```

æŸ¥çœ‹Il å‘ç°C#ç¼–è¯‘å™¨ç”Ÿæˆäº†ä¸€ä¸ªç§æœ‰çš„åµŒå¥—ç±» (åˆ æ‰äº†æ–¹æ³•ä½“é‡Œçš„ILä»£ç )

```cs
 .class auto ansi serializable sealed nested private beforefieldinit '<>c'
         extends [System.Runtime]System.Object
  {
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public static initonly class Lambda.Program/'<>c' '<>9'
    .field public static class [System.Runtime]System.Func`3<int32,int32,int32> '<>9__0_0'
    .field public static class [System.Runtime]System.Func`4<int32,int32,int32,int32> '<>9__0_1'
    .method private hidebysig specialname rtspecialname static 
            void  .cctor() cil managed
    {
    } // end of method '<>c'::.cctor
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
    } // end of method '<>c'::.ctor
    .method assembly hidebysig instance int32 
            '<Main>b__0_0'(int32 a,
                           int32 b) cil managed
    {
    } // end of method '<>c'::'<Main>b__0_0'
    .method assembly hidebysig instance int32 
            '<Main>b__0_1'(int32 a,
                           int32 b,
                           int32 c) cil managed
    {
    } // end of method '<>c'::'<Main>b__0_1'
  } // end of class '<>c'

```

æœ‰æˆå‘˜å¦‚ä¸‹ï¼š

- å…¬å…±é™æ€åªè¯»å­—æ®µ `<>9`ï¼Œç±»å‹ä¸º `Lambda.Program/'<>c'` (è‡ªå·±ç±»çš„ä¸€ä¸ªé™æ€å®ä¾‹)
- å…¬å…±é™æ€å­—æ®µ `<>9__0_0`ï¼Œç±»å‹ä¸º `System.Func3<int32,int32,int32>`
- å…¬å…±é™æ€å­—æ®µ `<>9__0_1`ï¼Œç±»å‹ä¸º `System.Func4<int32,int32,int32,int32>`
- å®ä¾‹æ–¹æ³• `<Main>b__0_0` å¯¹åº”æˆ‘ç¬¬ä¸€ä¸ªlambdaè¡¨è¾¾å¼
- å®ä¾‹æ–¹æ³• `<Main>b__0_1` å¯¹åº”æˆ‘ç¬¬äºŒä¸ªlambdaè¡¨è¾¾å¼

Mainæ–¹æ³•IL

```cs
   .method public hidebysig static void  Main(string[] args) cil managed
  {
    .custom instance void System.Runtime.CompilerServices.NullableContextAttribute::.ctor(uint8) = ( 01 00 01 00 00 ) 
    // Code size       95 (0x5f)
    .maxstack  4
    .locals init (class [System.Runtime]System.Func`3<int32,int32,int32> V_0)
    IL_0000:  ldsfld     class [System.Runtime]System.Func`3<int32,int32,int32> Lambda.Program/'<>c'::'<>9__0_0'
    IL_0005:  dup
  
    IL_0006:  brtrue.s   IL_001f // è¿™é‡Œæœ‰ä¸€ä¸ªæµç¨‹æ§åˆ¶ï¼Œåˆ¤æ–­æ ˆä¸Šå˜é‡æ˜¯å¦ trueï¼Œæ˜¯å¦null
    // --------------------- ä½¿å¾—ä¸‹é¢è¿™æ®µé€»è¾‘ åœ¨å¤šæ¬¡æ–¹æ³•è°ƒç”¨åªä¼šåˆ›å»ºä¸€ä¸ªå§”æ‰˜å®ä¾‹
    IL_0008:  pop
    IL_0009:  ldsfld     class Lambda.Program/'<>c' Lambda.Program/'<>c'::'<>9'
    IL_000e:  ldftn      instance int32 Lambda.Program/'<>c'::'<Main>b__0_0'(int32,
                                                                             int32)
    IL_0014:  newobj     instance void class [System.Runtime]System.Func`3<int32,int32,int32>::.ctor(object, native int)
    IL_0019:  dup

    IL_001a:  stsfld     class [System.Runtime]System.Func`3<int32,int32,int32> Lambda.Program/'<>c'::'<>9__0_0'
    // -------------------------
    IL_001f:  stloc.0 // è·³è½¬åˆ°è¿™é‡Œ
    IL_0020:  ldsfld     class [System.Runtime]System.Func`4<int32,int32,int32,int32> Lambda.Program/'<>c'::'<>9__0_1'
    IL_0025:  dup
    IL_0026:  brtrue.s   IL_003f
    IL_0028:  pop
    IL_0029:  ldsfld     class Lambda.Program/'<>c' Lambda.Program/'<>c'::'<>9'
    IL_002e:  ldftn      instance int32 Lambda.Program/'<>c'::'<Main>b__0_1'(int32,int32,int32)
    IL_0034:  newobj     instance void class [System.Runtime]System.Func`4<int32,int32,int32,int32>::.ctor(object, native int)
    IL_0039:  dup
  
    IL_003a:  stsfld     class [System.Runtime]System.Func`4<int32,int32,int32,int32> Lambda.Program/'<>c'::'<>9__0_1'
    IL_003f:  ldloc.0
    IL_0040:  ldc.i4.s   10
    IL_0042:  ldc.i4.s   12
    IL_0044:  callvirt   instance !2 class [System.Runtime]System.Func`3<int32,int32,int32>::Invoke(!0,!1)
    IL_0049:  call       void [System.Console]System.Console::WriteLine(int32)
  
    IL_004e:  ldc.i4.s   10
    IL_0050:  ldc.i4.s   12
    IL_0052:  ldc.i4.s   14
    IL_0054:  callvirt   instance !3 class [System.Runtime]System.Func`4<int32,int32,int32,int32>::Invoke(!0,!1,!2)
    IL_0059:  call       void [System.Console]System.Console::WriteLine(int32)
    IL_005e:  ret
  } // end of method Program::Main
```

### æ•è·å±€éƒ¨å˜é‡

```cs
    internal class Program
    {
        public static void Main(string[] args)
        {
            int d = 10;
            Func<int, int, int> ac1 = (a, b) => { return a + b + d; };
            Func<int, int, int, int> ac2 = (a, b, c) => { return a + b + c + d; };

            Console.WriteLine(ac1(10, 12));
            Console.WriteLine(ac2(10, 12, 14));
        }
    }

```

```cs
.class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass0_0'
         extends [System.Runtime]System.Object
  {
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 d
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
    } // end of method '<>c__DisplayClass0_0'::.ctor
    .method assembly hidebysig instance int32 
            '<Main>b__0'(int32 a,
                         int32 b) cil managed
    {
    } // end of method '<>c__DisplayClass0_0'::'<Main>b__0'
    .method assembly hidebysig instance int32 
            '<Main>b__1'(int32 a,
                         int32 b,
                         int32 c) cil managed
    {
    } // end of method '<>c__DisplayClass0_0'::'<Main>b__1'
  } // end of class '<>c__DisplayClass0_0'
```

- å…¬å…±çš„32ä½æ•´æ•°å­—æ®µ `d` ï¼ˆå¯¹åº”å±€éƒ¨å˜é‡ dï¼‰
- å®ä¾‹æ–¹æ³• `<Main>b__0`
- å®ä¾‹æ–¹æ³• `<Main>b__1`

æ•è·äº†å±€éƒ¨å˜é‡ï¼Œä¸¤ä¸ªé™æ€å§”æ‰˜å­—æ®µå’Œè‡ªå·±ç±»çš„é™æ€å®ä¾‹å°±æ²¡äº†

Mainæ–¹æ³•IL

```cs
.method public hidebysig static void  Main(string[] args) cil managed
  {
    .custom instance void System.Runtime.CompilerServices.NullableContextAttribute::.ctor(uint8) = ( 01 00 01 00 00 ) 
    // Code size       69 (0x45)
    .maxstack  4
    .locals init (class [System.Runtime]System.Func`3<int32,int32,int32> V_0)
    IL_0000:  newobj     instance void Lambda.Program/'<>c__DisplayClass0_0'::.ctor()
    IL_0005:  dup
  
    IL_0006:  ldc.i4.s   10
    IL_0008:  stfld      int32 Lambda.Program/'<>c__DisplayClass0_0'::d
    IL_000d:  dup
    IL_000e:  ldftn      instance int32 Lambda.Program/'<>c__DisplayClass0_0'::'<Main>b__0'(int32, int32)
    IL_0014:  newobj     instance void class [System.Runtime]System.Func`3<int32,int32,int32>::.ctor(object, native int)
  
    IL_0019:  stloc.0
    IL_001a:  ldftn      instance int32 Lambda.Program/'<>c__DisplayClass0_0'::'<Main>b__1'(int32, int32, int32)
    IL_0020:  newobj     instance void class [System.Runtime]System.Func`4<int32,int32,int32,int32>::.ctor(object, native int)
  
    IL_0025:  ldloc.0
    IL_0026:  ldc.i4.s   10
    IL_0028:  ldc.i4.s   12
    IL_002a:  callvirt   instance !2 class [System.Runtime]System.Func`3<int32,int32,int32>::Invoke(!0, !1)
    IL_002f:  call       void [System.Console]System.Console::WriteLine(int32)
  
    IL_0034:  ldc.i4.s   10
    IL_0036:  ldc.i4.s   12
    IL_0038:  ldc.i4.s   14
    IL_003a:  callvirt   instance !3 class [System.Runtime]System.Func`4<int32,int32,int32,int32>::Invoke(!0,!1, !2)
    IL_003f:  call       void [System.Console]System.Console::WriteLine(int32)
    IL_0044:  ret
  } // end of method Program::Main
```

æ€»ç»“ï¼š

- æ²¡æœ‰æ•è·ä¸Šä¸‹æ–‡çš„lambdaè¡¨è¾¾å¼ä¼šåœ¨åµŒå¥—ç±»ä¸­ç”Ÿæˆ é™æ€çš„å®ä¾‹å’Œé™æ€çš„å§”æ‰˜å­—æ®µï¼ˆlambdaè¡¨è¾¾å¼å†™çš„æ–¹æ³•ï¼‰
  - å¹¶ä¸”é€šè¿‡ä¸€ä¸ªæµç¨‹æ§åˆ¶è¯­å¥ï¼Œä½¿å¾—å¤šæ¬¡è¿›å…¥æ–¹æ³•ä¸ä¼šåˆ›å»ºç›¸åŒçš„å§”æ‰˜å®ä¾‹ã€‚
- æœ‰æ•è·ä¸Šä¸‹æ–‡ï¼ˆåªæ•è·å®ä¾‹å˜é‡ï¼Œé™æ€å˜é‡ç›´æ¥é€šè¿‡ç±»åè°ƒç”¨ï¼‰ï¼Œä¼šå°†ä¸Šä¸‹æ–‡åŒ…è£…åˆ°åµŒå¥—ç±»ä¸­ã€‚
- ä¸€ä¸ªæ–¹æ³•å†…çš„æ‰€æœ‰lambdaä¼šå…±äº«ä¸€ä¸ªåµŒå¥—ç±»

## 2. ç‰¹æ€§å¯ä»¥ä¼ å…¥è‡ªå®šä¹‰ Struct å—

```cs
    struct MyStruct
    {
    }

    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
    sealed class MyAttribute : Attribute
    {
        private MyStruct ms;

        public MyAttribute(MyStruct ms)
        {
            this.ms = ms;
        }
    }

    [My(new MyStruct())] // è¿™é‡ŒæŠ¥é”™ Attribute constructor parameter 'ms' has type 'AttrMStructCanDo.MyStruct', which is not a valid attribute parameter type
    internal class Program
    {
        public static void Main(string[] args)
        {
        }
    }
```

> åº”ç”¨ç‰¹æ€§æ—¶å¿…é¡»ä¼ é€’ä¸€ä¸ªç¼–è¯‘æ—¶å¸¸é‡è¡¨è¾¾å¼ï¼Œå®ƒä¸ç‰¹æ€§ç±»å®šä¹‰çš„ç±»å‹åŒ¹é…ã€‚åœ¨ç‰¹æ€§ç±»å®šä¹‰äº†ä¸€ä¸ª `Type`å‚æ•°ã€`Type`å­—æ®µæˆ–è€… `Type`å±æ€§çš„ä»»ä½•åœ°æ–¹ï¼Œéƒ½å¿…é¡»ä½¿ç”¨ C# `typeof` æ“ä½œç¬¦(å¦‚ä¸‹ä¾‹æ‰€ç¤º)ã€‚åœ¨ç‰¹æ€§ç±»å®šä¹‰äº†ä¸€ä¸ª `Object` å‚æ•°ã€`Object`å­—æ®µæˆ–è€… `Object` å±æ€§çš„ä»»ä½•åœ°æ–¹ï¼Œéƒ½å¯ä¼ é€’ä¸€ä¸ª `Int32`ã€`String` æˆ–å…¶ä»–ä»»ä½•å¸¸é‡è¡¨è¾¾å¼(åŒ…æ‹¬ `null`)ã€‚å¦‚æœå¸¸é‡è¡¨è¾¾å¼ä»£è¡¨å€¼ç±»å‹ï¼Œé‚£ä¹ˆåœ¨è¿è¡Œæ—¶æ„é€ ç‰¹æ€§çš„å®ä¾‹æ—¶ä¼šå¯¹å€¼ç±»å‹è¿›è¡Œè£…ç®±ã€‚

 å®šä¹‰é»˜è®¤å‚æ•°, ç¼–è¯‘æ—¶ä¼šæŠ¥é”™
 Error CS0181 : ç‰¹æ€§æ„é€ å‡½æ•°å‚æ•°â€œmsâ€å…·æœ‰ç±»å‹â€œMyStructâ€ï¼Œè¿™ä¸æ˜¯æœ‰æ•ˆç‰¹æ€§å‚æ•°ç±»å‹

```cs

    struct MyStruct
    {
    }

    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
    sealed class MyAttribute : Attribute
    {
        private MyStruct ms;

        public MyAttribute(MyStruct ms = default)
        {
            this.ms = ms;
        }
    }

    [My()]
    internal class Program
    {
        public static void Main(string[] args)
        {
        }
    }
```

> å¼•ç”¨MSDN
> è‡ªå®šä¹‰ç‰¹æ€§å®šä¹‰åŒ…æ‹¬å¯¹å‚æ•°æŒ‡å®šæ— æ•ˆæ•°æ®ç±»å‹çš„æ„é€ å‡½æ•°ã€‚ ç‰¹æ€§åªèƒ½ä»¥æŸäº›æ•°æ®ç±»å‹ä½œä¸ºå‚æ•°ï¼Œå› ä¸ºåªæœ‰è¿™äº›ç±»å‹å¯åºåˆ—åŒ–åˆ°ç¨‹åºé›†çš„å…ƒæ•°æ®ã€‚

ç‰¹æ€§é€šå¸¸åœ¨è¿è¡Œæ—¶é€šè¿‡åå°„æ¥è¯»å–ï¼Œè€Œè¿™äº›å€¼éœ€è¦ä»¥ä¸€ç§å¯åºåˆ—åŒ–çš„å½¢å¼å­˜å‚¨åœ¨ç¨‹åºé›†å…ƒæ•°æ®ä¸­ï¼š

- åŸºç¡€ç±»å‹ã€å­—ç¬¦ä¸²ã€æšä¸¾ç­‰æ˜¯å¯åºåˆ—åŒ–çš„ï¼Œå¯ä»¥ç›´æ¥å­˜å‚¨åœ¨å…ƒæ•°æ®ä¸­ã€‚
- è‡ªå®šä¹‰å€¼ç±»å‹å¯èƒ½åŒ…å«å¤æ‚çš„å†…éƒ¨çŠ¶æ€æˆ–è¡Œä¸ºï¼Œç”šè‡³å¯èƒ½åŒ…å«å¼•ç”¨ç±»å‹å­—æ®µï¼Œè¿™äº›å­—æ®µåœ¨å…ƒæ•°æ®ä¸­æ— æ³•ç›´æ¥å­˜å‚¨ã€‚

## 3. å¤šæ¬¡è°ƒç”¨ GetCustomAttribute æ•ˆç‡ä¸€æ ·å— ï¼ˆæœ‰ä¼˜åŒ–å—ï¼‰

ä¸ä¼šæœ‰ä¼˜åŒ–ï¼Œä¹¦ä¸Šæ²¡æœ‰ç›¸å…³æè¿°

å†™ä¸ªæµ‹è¯•

```cs
   public class Program
    {
        public static void Main(string[] args)
        {
            BenchmarkRunner.Run<Program>();
        }

        [Benchmark]
        public void Test3()
        {
            var type = typeof(Program);
            type.GetCustomAttributes(true);
            type.GetCustomAttributes(true);
            type.GetCustomAttributes(true);
            type.GetCustomAttributes(true);
        }

        [Benchmark(Baseline = true)]
        public void Test2()
        {
            var type = typeof(Program);
            type.GetCustomAttributes(true);
            type.GetCustomAttributes(true);
        }
    }
```

| Method |     Mean |     Error |    StdDev | Ratio |
| ------ | -------: | --------: | --------: | ----: |
| Test3  | 3.303 us | 0.0141 us | 0.0132 us |  1.98 |
| Test2  | 1.668 us | 0.0098 us | 0.0082 us |  1.00 |

## 4. Attribute.Equal æœ‰å®ç°å—

æœ‰é»˜è®¤å®ç°ï¼Œé€»è¾‘æ˜¯ä½¿ç”¨åå°„è·å–æ¯ä¸ªå­—æ®µï¼Œç„¶åé€ä¸€æ¯”è¾ƒã€‚

```cs

    [SecuritySafeCritical]
    [__DynamicallyInvokable]
    public override bool Equals(object obj)
    {
      if (obj == null)
        return false;
      RuntimeType type = (RuntimeType) this.GetType();
      if ((RuntimeType) obj.GetType() != type)
        return false;
      object obj1 = (object) this;
      FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
      for (int index = 0; index < fields.Length; ++index)
      {
        if (!Attribute.AreFieldValuesEqual(((RtFieldInfo) fields[index]).UnsafeGetValue(obj1), ((RtFieldInfo) fields[index]).UnsafeGetValue(obj)))
          return false;
      }
      return true;
    }

    private static bool AreFieldValuesEqual(object thisValue, object thatValue)
    {
      if (thisValue == null && thatValue == null)
        return true;
      if (thisValue == null || thatValue == null)
        return false;
      if (thisValue.GetType().IsArray)
      {
        if (!thisValue.GetType().Equals(thatValue.GetType()))
          return false;
        Array array1 = thisValue as Array;
        Array array2 = thatValue as Array;
        if (array1.Length != array2.Length)
          return false;
        for (int index = 0; index < array1.Length; ++index)
        {
          if (!Attribute.AreFieldValuesEqual(array1.GetValue(index), array2.GetValue(index)))
            return false;
        }
      }
      else if (!thisValue.Equals(thatValue))
        return false;
      return true;
    }
```

## 5. Nullable<> æœ‰ä»€ä¹ˆæ³›å‹çº¦æŸï¼Œä¸Šé¢åŠ äº†ä»€ä¹ˆç‰¹æ€§ï¼Œå®ƒçš„å¤§å°æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ

```cs
  [NonVersionable] // å®ç°ä¸è½»æ˜“éšç‰ˆæœ¬å˜åŒ–ä¿®æ”¹
  [__DynamicallyInvokable] // åŠ¨æ€åå°„è°ƒç”¨
  [Serializable] // å¯åºåˆ—åŒ–
  [method: NonVersionable] 
  [method: __DynamicallyInvokable] 
  public struct Nullable<T>(T value) where T : struct
  {
	}
```

Nullable<\T>  é‡Œé¢æœ‰
bool hasValue
T vlaue

å…·ä½“çš„å¤§å°ï¼Œæ ¹æ®Tçš„å¤§å°è€Œå®šï¼ˆç”±äºå­—èŠ‚å¯¹é½ï¼‰
bool å ä¸€ä¸ªå­—èŠ‚ï¼Œåé¢è¦è¡¥é½ Tçš„å¤§å°
æ‰€ä»¥ Nullableå¤§å°æ˜¯ 2 * sizeof(T);

## 6. int? a = 1; a.GetType();æ˜¯å¦‚ä½•è°ƒç”¨çš„ï¼Œä¸ºä»€ä¹ˆä¼šè¿”å› int çš„typeå®ä¾‹

é€»è¾‘ä¸Šæ¥è¯´æ˜¯ï¼ša.GetType() è¿™é‡Œä¼šå‘ç”Ÿè£…ç®±ï¼Œå§ a é‡Œé¢çš„int æ‹¿å‡ºæ¥è£…ç®±ï¼Œç„¶åè°ƒç”¨è£…ç®±åçš„å¯¹è±¡çš„GetTypeï¼Œå› æ­¤ä¼šè¿”å›int typeå®ä¾‹

## 7. int? a = null; a.GetType(); æ˜¯åœ¨å“ªé‡ŒæŠ›å‡ºçš„å¼‚å¸¸ï¼Ÿ

```cs
int? a = null;
a.GetType();
```

ä»£ç å®é™…æƒ…å†µæ˜¯ä¸‹é¢çš„ï¼š

```cs
int? a = 1;
object o = a;
var type = o.GetType();
Console.WriteLine(type);
```

ä¸­é—´éƒ¨åˆ†ILå¦‚ä¸‹

```cs
    // [10 13 - 10 26]
    IL_0009: ldloc.0      // a
    IL_000a: box          valuetype [mscorlib]System.Nullable`1<int32>
    IL_000f: stloc.1      // o

    // [11 13 - 11 36]
    IL_0010: ldloc.1      // o
    IL_0011: callvirt     instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0016: stloc.2      // 'type'
```

`callvirt` ä¸­åšçš„nullreferenceExcptionæŠ›å‡º

> `callvirt`
> è¯¥ IL æŒ‡ä»¤å¯è°ƒç”¨å®ä¾‹æ–¹æ³•å’Œè™šæ–¹æ³•ï¼Œä¸èƒ½è°ƒç”¨é™æ€æ–¹æ³•ã€‚
> ç”¨ `callvirt` æŒ‡ä»¤è°ƒç”¨å®ä¾‹æ–¹æ³•æˆ–è™šæ–¹æ³•ï¼Œå¿…é¡»æŒ‡å®šå¼•ç”¨äº†å¯¹è±¡çš„å˜é‡ã€‚
> ç”¨ `callvirt` æŒ‡ä»¤è°ƒç”¨éè™šå®ä¾‹æ–¹æ³•ï¼Œå˜é‡çš„ç±»å‹æŒ‡æ˜äº†æ–¹æ³•çš„å®šä¹‰ç±»å‹ã€‚
>
> ç”¨ `callvirt` æŒ‡ä»¤è°ƒç”¨è™šå®ä¾‹æ–¹æ³•ï¼ŒCLR è°ƒæŸ¥å‘å‡ºè°ƒç”¨çš„å¯¹è±¡çš„å®é™…ç±»å‹ï¼Œç„¶åä»¥å¤šæ€æ–¹å¼è°ƒç”¨æ–¹æ³•ã€‚
> ä¸ºäº†ç¡®å®šç±»å‹ï¼Œå‘å‡ºè°ƒç”¨çš„å˜é‡ç»ä¸èƒ½æ˜¯ `null`ã€‚æ¢è¨€ä¹‹ï¼Œç¼–è¯‘è¿™ä¸ªè°ƒç”¨æ—¶ï¼ŒJIT ç¼–è¯‘å™¨ä¼šç”Ÿæˆä»£ç æ¥éªŒè¯å˜é‡çš„å€¼æ˜¯ä¸æ˜¯ `null`ã€‚å¦‚æœæ˜¯ï¼Œ `callvirt` æŒ‡ä»¤çš„æ‰§è¡Œé€Ÿåº¦æ¯” `call` æŒ‡ä»¤ç¨æ…¢ã€‚æ³¨æ„ï¼Œå³ä½¿ `callvirt` æŒ‡ä»¤è°ƒç”¨çš„æ˜¯éè™šå®ä¾‹æ–¹æ³•ï¼Œä¹Ÿè¦æ‰§è¡Œè¿™ç§ `null`æ£€æŸ¥ã€‚

## 8. Finally è¯­å¥ä¸ºä»€ä¹ˆä¼šæ‰§è¡Œï¼Œå®ƒçš„æœºåˆ¶æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ

> å®šä¹‰å‚è€ƒ:
> finally ä»£ç å—ç”¨äºæ¸…ç† try ä»£ç å—ä¸­åˆ†é…çš„ä»»ä½•èµ„æºï¼Œä»¥åŠè¿è¡Œå³ä½¿å‘ç”Ÿå¼‚å¸¸ä¹Ÿå¿…é¡»æ‰§è¡Œçš„ä»»ä½•ä»£ç ã€‚æ— è®º try ä»£ç å—å¦‚ä½•é€€å‡ºï¼Œæ§åˆ¶æƒå§‹ç»ˆä¼ é€’ç»™ finally ä»£ç å—ã€‚

```cs
    internal class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("In try block");
                throw new Exception();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                Console.WriteLine("In finally block");
            }

            Console.WriteLine("After finally block");
        }
    }

```

```cs
 .method public hidebysig static void
    Main(
      string[] args
    ) cil managed
  {
    .entrypoint
    .maxstack 1
    .locals init (
      [0] class [mscorlib]System.Exception e
    )

    // [8 9 - 8 10]
    IL_0000: nop
    .try
    {
      .try
      {
        // [10 13 - 10 14]
        IL_0001: nop

        // [11 17 - 11 51]
        IL_0002: ldstr        "In try block"
        IL_0007: call         void [mscorlib]System.Console::WriteLine(string)
        IL_000c: nop

        // [12 17 - 12 39]
        IL_000d: newobj       instance void [mscorlib]System.Exception::.ctor()
        IL_0012: throw
      } // end of .try
      catch [mscorlib]System.Exception
      {

        // [14 13 - 14 32]
        IL_0013: stloc.0      // e

        // [15 13 - 15 14]
        IL_0014: nop

        // [16 17 - 16 38]
        IL_0015: ldloc.0      // e
        IL_0016: call         void [mscorlib]System.Console::WriteLine(object)
        IL_001b: nop

        // [17 13 - 17 14]
        IL_001c: nop
        IL_001d: leave.s      IL_001f
      } // end of catch

      IL_001f: leave.s      IL_002f
    } // end of .try
    finally
    {

      // [19 13 - 19 14]
      IL_0021: nop

      // [20 17 - 20 55]
      IL_0022: ldstr        "In finally block"
      IL_0027: call         void [mscorlib]System.Console::WriteLine(string)
      IL_002c: nop

      // [21 13 - 21 14]
      IL_002d: nop
      IL_002e: endfinally
    } // end of finally

    // [23 13 - 23 54]
    IL_002f: ldstr        "After finally block"
    IL_0034: call         void [mscorlib]System.Console::WriteLine(string)
    IL_0039: nop

    // [24 9 - 24 10]
    IL_003a: ret

  } // end of method Program::Main

```

ä¸»è¦æ˜¯ä»æµç¨‹æ§åˆ¶çš„è§’åº¦å®ç°çš„ï¼Œtryä¸­é€»è¾‘æ‰§è¡Œå®Œæ²¡æœ‰æŠ›å‡ºå¼‚å¸¸åœ¨ä»£ç æµç¨‹ä¸­å°±èƒ½è·³è½¬åˆ°finallyå—ä¸­ï¼Œå¦‚æœæŠ›å‡ºäº†å¼‚å¸¸ï¼Œè¢«æœ¬å±‚çš„catchå—æ•è·äº†ï¼Œcatchå—æ‰§è¡Œå®Œæˆåè·³è½¬åˆ°finallyï¼Œå¦‚ä½•æ²¡è¢«æ•è·è€Œè¢«å¤–å±‚æ•è·äº†ï¼Œåˆ™æ‰§è¡ŒCLRä¼šæ‰§è¡Œå†…å±‚çš„finallyè¯­å¥å—ï¼Œå‡å¦‚æ²¡è¢«æ‰˜ç®¡ä»£ç æ•è·ï¼Œè¿™CLRæ‰§è¡Œæµç¨‹ä¸­åº”è¯¥ä¹Ÿæœ‰æ‰§è¡Œfinallyè¯­å¥å—çš„é€»è¾‘ã€‚

å¦‚æœä¸éµå®ˆæµç¨‹æ§åˆ¶çš„é€»è¾‘ï¼Œæˆ–è€…æ— æ³•æ‰§è¡Œåˆ™å¯èƒ½ä¸ä¼šæ‰§è¡Œfinallyï¼Œå¦‚ä¸‹è®¨è®ºçš„ã€‚

### ä¾‹å¤–çš„æƒ…å†µ [try catch - C# çš„ &#34;finally&#34; å—æ€»æ˜¯æ‰§è¡Œå—ï¼Ÿ - Stack Overflow --- try catch - Does the C# &#34;finally&#34; block ALWAYS execute? - Stack Overflow](https://stackoverflow.com/questions/3216046/does-the-c-sharp-finally-block-always-execute)

- ä»»ä½•ç›´æ¥ç»ˆæ­¢è¿›ç¨‹è€Œä¸æ˜¯è®©å…¶è‡ªè¡Œæ¸©å’Œå…³é—­çš„æ“ä½œéƒ½å°†é˜»æ­¢Â `finally`Â çš„è¿è¡Œ
  1. Environment.FailFast
  2. Power FailureÂ ç”µæºæ•…éšœ
- å‡ºç° StackOverflowException æ—¶ä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºæ ˆä¸­æ²¡æœ‰ç©ºé—´æ‰§è¡Œä»»ä½•æ›´å¤šä»£ç ã€‚
- å‡ºç°æå…¶ç½•è§çš„ ExecutingEngineException æ—¶ï¼Œå®ƒä¹Ÿä¸ä¼šè¢«è°ƒç”¨ã€‚

## 9. throw e å’Œ throw çš„åŒºåˆ«

```cs
try {

} catch (Exection e) {
	// throw e;
	throw;
}
```

throw å¯¹åº”çš„IL æ˜¯
IL_0019: rethrow

throw e å¯¹åº”çš„IL æ˜¯ï¼š
IL_0019: ldloc.0      // e
IL_001a: throw

### åšä¸ªæµ‹è¯•

```cs
   internal class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                Test();
            }
            catch (Exception e)
            {
                Console.WriteLine(e); // è°ƒè¯•è¿™é‡Œçš„å¼‚å¸¸
            }

            Console.WriteLine("After finally block");
        }

        static void Test()
        {
            try
            {
                TestInner();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
            finally
            {
                Console.WriteLine("In finally block");
            }
        }

        static void TestInner()
        {
            throw new Exception();
        }
```

```
System.Exception: å¼•å‘ç±»å‹ä¸ºâ€œSystem.Exceptionâ€çš„å¼‚å¸¸ã€‚
   åœ¨ WhyFinally.Program.TestInner() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 41
   åœ¨ WhyFinally.Program.Test() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 26
   
In finally block

System.Exception: å¼•å‘ç±»å‹ä¸ºâ€œSystem.Exceptionâ€çš„å¼‚å¸¸ã€‚
   åœ¨ WhyFinally.Program.TestInner() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 41
   åœ¨ WhyFinally.Program.Test() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 31
   åœ¨ WhyFinally.Program.Main(String[] args) ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 11

```

Test æ–¹æ³•é‡Œé¢catch å—æ”¹æˆ throw e;

```cs
System.Exception: å¼•å‘ç±»å‹ä¸ºâ€œSystem.Exceptionâ€çš„å¼‚å¸¸ã€‚
   åœ¨ WhyFinally.Program.TestInner() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 40
   åœ¨ WhyFinally.Program.Test() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 25
In finally block

System.Exception: å¼•å‘ç±»å‹ä¸ºâ€œSystem.Exceptionâ€çš„å¼‚å¸¸ã€‚
   åœ¨ WhyFinally.Program.Test() ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 30
   åœ¨ WhyFinally.Program.Main(String[] args) ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 11
After finally block
```

å¯è§ throw e; ä¼šè¢«è§†ä¸ºé‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼ŒCLRä¼šé‡ç½®è°ƒç”¨æ ˆçš„èµ·ç‚¹ã€‚

## 10. ä¸æ ‡è®°å¯åºåˆ—åŒ–ï¼ŒæŠ›å‡ºå¼‚å¸¸ä¼šæ€ä¹ˆæ ·ï¼Ÿ

```cs
    public class MyException : Exception
    {
        public MyException()
        {
        }

        public MyException(string message) : base(message)
        {
        }

        public MyException(string message, Exception inner) : base(message, inner)
        {
        }
    }

    internal class Program
    {
        public static void Main(string[] args)
        {
            throw new MyException();
        }
    }
```

ä¸æ ‡è®°ä¹Ÿèƒ½æ­£å¸¸æŠ›å‡º

```
æœªç»å¤„ç†çš„å¼‚å¸¸:  WhyFinally.MyException: å¼•å‘ç±»å‹ä¸ºâ€œWhyFinally.MyExceptionâ€çš„å¼‚å¸¸ã€‚
   åœ¨ WhyFinally.Program.Main(String[] args) ä½ç½® D:\Study\CLR_via_CSharp\resources\SourceCodes\CLR_via_CSharp\WhyFinally\Program.cs:è¡Œå· 24
```

### æµ‹è¯•åµŒå¥— AppDemain

```cs
    public class MyException : Exception
    {
        private string s;

        public MyException(string s)
        {
            this.s = s;
        }

        public MyException(string s, string message) : base(message)
        {
            this.s = s;
        }

        public MyException(string s, string message, Exception inner) : base(message, inner)
        {
            this.s = s;
        }
    }

    internal class Program
    {
        public static void Main(string[] args)
        {
            TestControl.Go();
        }
    }

    class TestControl
    {
        public static void Go()
        {
            // åˆ›å»ºæ–°çš„ AppDomain
            AppDomain newDomain = AppDomain.CreateDomain("NewDomain");

            // åœ¨æ–° AppDomain ä¸­æ‰§è¡Œä»£ç 
            try
            {
                newDomain.DoCallBack(() =>
                {
                    try
                    {
                        // åœ¨æ–° AppDomain ä¸­æŠ›å‡º MyException å¼‚å¸¸
                        throw new MyException("MyException", "This is an un-serializable exception");
                    }
                    catch (Exception e)
                    {
                        // æ•æ‰å¹¶æ‰“å°å¼‚å¸¸ä¿¡æ¯
                        Console.WriteLine($"Caught exception in new AppDomain: {e.GetType().Name} - {e.Message}");
                        throw;
                    }
                });
            }
            catch (Exception e)
            {
                // æ•æ‰ä¼ é€’åˆ°åŸå§‹ AppDomain ä¸­çš„å¼‚å¸¸
                Console.WriteLine($"Caught exception in original AppDomain: {e.GetType().Name} - {e.Message}");
            }
            finally
            {
                // å¸è½½æ–°çš„ AppDomain
                AppDomain.Unload(newDomain);
            }
        }
    }

```

è¾“å‡ºå¦‚ä¸‹ï¼š

```cs
Caught exception in new AppDomain: MyException - This is an un-serializable exception

Caught exception in original AppDomain: SerializationException - ç¨‹åºé›†â€œWhyFinally, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullâ€ä¸­çš„ç±»å‹â€œWhyFinally.MyExceptionâ€æœªæ ‡è®°ä¸ºå¯åºåˆ—åŒ–ã€‚
```

è¿è¡Œæ—¶æŠ¥é”™ SerializationException

ä¿®æ”¹ä¸€ä¸‹å¼‚å¸¸ç±»

```cs
  [Serializable]
    public class MyException : Exception
    {
        private string s;

        public MyException(string s)
        {
            this.s = s;
        }

        public MyException(string s, string message) : base(message)
        {
            this.s = s;
        }

        public MyException(string s, string message, Exception inner) : base(message, inner)
        {
            this.s = s;
        }

        protected MyException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            s = info.GetString("s");
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("s", s);
        }
    }
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```cs
Caught exception in new AppDomain: MyException - This is an un-serializable exception
Caught exception in original AppDomain: MyException - This is an un-serializable exception
```

å¤–å±‚å¯ä»¥æ­£å¸¸æ•è·ã€‚

## 11 malloc æ˜¯å¦çº¿ç¨‹å®‰å…¨ï¼ŒC# çš„GCçš„å†…å­˜åˆ†é…å‘¢ï¼Ÿï¼ˆNextObjPtræŒ‡é’ˆï¼‰


### malloc

[c - Is malloc thread-safe? - Stack Overflow](https://stackoverflow.com/questions/855763/is-malloc-thread-safe)

From theÂ [GNU C Library Reference Manual](http://www.gnu.org/software/libc/manual/html_mono/libc.html#Basic-Allocation)Â ofÂ `glibc-2.20 [released 2014-09-07]`:

> `void * malloc (size_t size)`
> 
> Preliminary: MT-Safe | ...
> 
> ... 1.2.2.1 POSIX Safety Concepts:
> 
> ... MT-Safe or Thread-Safe functions are safe to call in the presence of other threads. MT, in MT-Safe, stands for Multi Thread.
> 
> Being MT-Safe does not imply a function is atomic, nor that it uses any of the memory synchronization mechanisms POSIX exposes to users. It is even possible that calling MT-Safe functions in sequence does not yield an MT-Safe combination. For example, having a thread call two MT-Safe functions one right after the other does not guarantee behavior equivalent to atomic execution of a combination of both functions, since concurrent calls in other threads may interfere in a destructive way.
> 
> Whole-program optimizations that could inline functions across library interfaces may expose unsafe reordering, and so performing inlining across the GNU C Library interface is not recommended. The documented MT-Safety status is not guaranteed underwhole-program optimization. However, functions defined in user-visible headers are designed to be safe for inlining.

ç›®å‰Â `malloc()`Â æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

GNU GLIBC-2.23 æºç 

```c

void *
malloc (size_t len)
{
  struct header *result = NULL;

  /* Determine real implementation if not already happened.  */
  if (__glibc_unlikely (initialized <= 0))
    {
      if (initialized == -1)
        return NULL;

      me ();
    }

  /* If this is not the correct program just use the normal function.  */
  if (not_me)
    return (*mallocp)(len);

  /* Keep track of number of calls.  */
  catomic_increment (&calls[idx_malloc]);
  /* Keep track of total memory consumption for `malloc'.  */
  catomic_add (&total[idx_malloc], len);
  /* Keep track of total memory requirement.  */
  catomic_add (&grand_total, len);
  /* Remember the size of the request.  */
  if (len < 65536)
    catomic_increment (&histogram[len / 16]);
  else
    catomic_increment (&large);
  /* Total number of calls of any of the functions.  */
  catomic_increment (&calls_total);

  /* Do the real work.  */
  result = (struct header *) (*mallocp)(len + sizeof (struct header));
  if (result == NULL)
    {
      catomic_increment (&failed[idx_malloc]);
      return NULL;
    }

  /* Update the allocation data and write out the records if necessary.  */
  update_data (result, len, 0);

  /* Return the pointer to the user buffer.  */
  return (void *) (result + 1);
}
```

é‡Œé¢ä¸€å †å®ï¼Œæš‚æ—¶çœ‹ä¸æ‡‚ğŸ˜¢
### C# å†…å­˜åˆ†é…

> .net 6 æºç  gchelpers.cpp
 
```cpp
inline Object* Alloc(size_t size, GC_ALLOC_FLAGS flags)
{
    CONTRACTL {
        THROWS;
        GC_TRIGGERS;
        MODE_COOPERATIVE; // returns an objref without pinning it => cooperative
    } CONTRACTL_END;

    _ASSERTE(!NingenEnabled() && "You cannot allocate managed objects inside the ngen compilation process.");

#ifdef _DEBUG
    if (g_pConfig->ShouldInjectFault(INJECTFAULT_GCHEAP))
    {
        char *a = new char;
        delete a;
    }
#endif

    if (flags & GC_ALLOC_CONTAINS_REF)
        flags &= ~GC_ALLOC_ZEROING_OPTIONAL;

    Object *retVal = NULL;
    CheckObjectSize(size);

    if (GCHeapUtilities::UseThreadAllocationContexts())
    {
        gc_alloc_context *threadContext = GetThreadAllocContext();
        GCStress<gc_on_alloc>::MaybeTrigger(threadContext);
        retVal = GCHeapUtilities::GetGCHeap()->Alloc(threadContext, size, flags);
    }
    else
    {
        GlobalAllocLockHolder holder(&g_global_alloc_lock);
        gc_alloc_context *globalContext = &g_global_alloc_context;
        GCStress<gc_on_alloc>::MaybeTrigger(globalContext);
        retVal = GCHeapUtilities::GetGCHeap()->Alloc(globalContext, size, flags);
    }


    if (!retVal)
    {
        ThrowOutOfMemory();
    }

    return retVal;
}
```

å¯ä»¥çœ‹åˆ°æœ‰ä¸­é—´ä¸€ä¸ªif è¯­å¥ é€‰æ‹© ä½¿ç”¨ çº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡ï¼ˆThreadAllocationContextsï¼‰æˆ–è€… globalContextã€‚
ï¼ˆ**çº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡**æŒ‡æ‰˜ç®¡å †ä¸Šé¢„åˆ†é…çš„ä¸€ä¸ªç©ºç™½ç©ºé—´ï¼Œç”¨äºçº¿ç¨‹çš„å†…å­˜åˆ†é…ï¼Œç”¨å®Œäº†å†åˆ†é…ï¼Œå‡å°‘ç”³è¯·å…¨å±€é”çš„å¼€é”€ã€‚ï¼‰

åˆ¤æ–­é€»è¾‘å¦‚ä¸‹ï¼š
```cpp
    static bool UseThreadAllocationContexts()
    {
        // When running on a single-proc Intel system, it's more efficient to use a single global
        // allocation context for SOH allocations than to use one for every thread.
#if (defined(TARGET_X86) || defined(TARGET_AMD64)) && !defined(TARGET_UNIX)
        return IsServerHeap() || ::g_SystemInfo.dwNumberOfProcessors != 1 || CPUGroupInfo::CanEnableGCCPUGroups();
#else
        return true;
#endif

    }
```

>å¼•ç”¨è‡ªGithub Coplots
>1. **å•å¤„ç†å™¨ Intel ç³»ç»Ÿ**ï¼š
    - åœ¨å•å¤„ç†å™¨çš„ Intel ç³»ç»Ÿä¸Šï¼ˆx86 æˆ– AMD64 æ¶æ„ï¼‰ï¼Œå¦‚æœä¸æ˜¯åœ¨ Unix ç³»ç»Ÿä¸Šè¿è¡Œï¼Œå‡½æ•°ä¼šé€‰æ‹©ä½¿ç”¨å…¨å±€åˆ†é…ä¸Šä¸‹æ–‡è€Œä¸æ˜¯æ¯ä¸ªçº¿ç¨‹ä¸€ä¸ªåˆ†é…ä¸Šä¸‹æ–‡ã€‚è¿™æ˜¯å› ä¸ºåœ¨å•å¤„ç†å™¨ç³»ç»Ÿä¸Šï¼Œä½¿ç”¨å…¨å±€åˆ†é…ä¸Šä¸‹æ–‡å¯ä»¥å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œé”äº‰ç”¨ï¼Œä»è€Œæé«˜æ•ˆç‡ã€‚
>2. **å¤šå¤„ç†å™¨æˆ–æœåŠ¡å™¨å †**ï¼š
    - å¦‚æœæ˜¯æœåŠ¡å™¨å †ï¼ˆ`IsServerHeap()`Â è¿”å›Â `true`ï¼‰ï¼Œæˆ–è€…ç³»ç»Ÿçš„å¤„ç†å™¨æ•°é‡ä¸ä¸º 1ï¼Œæˆ–è€…å¯ä»¥å¯ç”¨ CPU ç»„ï¼ˆ`CPUGroupInfo::CanEnableGCCPUGroups()`Â è¿”å›Â `true`ï¼‰ï¼Œåˆ™å‡½æ•°è¿”å›Â `true`ï¼Œè¡¨ç¤ºä½¿ç”¨çº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡ã€‚
    - è¿™æ„å‘³ç€åœ¨å¤šå¤„ç†å™¨ç¯å¢ƒä¸­ï¼Œæˆ–è€…åœ¨æœåŠ¡å™¨å †é…ç½®ä¸‹ï¼Œä½¿ç”¨çº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡å¯ä»¥æ›´å¥½åœ°åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨çš„å¹¶è¡Œæ€§ï¼Œæé«˜å†…å­˜åˆ†é…çš„æ•ˆç‡ã€‚
>3. **é Intel æˆ– Unix ç³»ç»Ÿ**ï¼š
      - åœ¨é Intel æ¶æ„æˆ– Unix ç³»ç»Ÿä¸Šï¼Œå‡½æ•°é»˜è®¤è¿”å›Â `true`ï¼Œè¡¨ç¤ºæ€»æ˜¯ä½¿ç”¨çº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡ã€‚è¿™æ˜¯å› ä¸ºåœ¨è¿™äº›ç¯å¢ƒä¸­ï¼Œçº¿ç¨‹åˆ†é…ä¸Šä¸‹æ–‡é€šå¸¸èƒ½æä¾›æ›´å¥½çš„æ€§èƒ½ã€‚


åœ¨ä½¿ç”¨å…¨å±€åˆ†é…ä¸Šä¸‹æ–‡è¿›è¡Œå†…å­˜åˆ†é…ï¼Œè·å–å…¨å±€åˆ†é…é”ã€‚é˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹å…¨å±€åˆ†é…ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ã€‚
```cpp
GlobalAllocLockHolder holder(&g_global_alloc_lock);

^
|

typedef GlobalAllocLock::Holder GlobalAllocLockHolder;

^
|

    typedef Holder<GlobalAllocLock *, GlobalAllocLock::AcquireLock, GlobalAllocLock::ReleaseLock> Holder;

^
|

    // Static helper to acquire a lock, for use with the Holder template.
    static void AcquireLock(GlobalAllocLock *lock)
    {
        WRAPPER_NO_CONTRACT;
        lock->Acquire();
    }

    // Static helper to release a lock, for use with the Holder template
    static void ReleaseLock(GlobalAllocLock *lock)
    {
        WRAPPER_NO_CONTRACT;
        lock->Release();
    }

```

lock æ˜¯ä¸€ä¸ª GlobalAllocLockç±»

```cpp
class GlobalAllocLock {
    friend struct AsmOffsets;
private:
    // The lock variable. This field must always be first.
    LONG m_lock;

public:
    // Creates a new GlobalAllocLock in the unlocked state.
    GlobalAllocLock() : m_lock(-1) {}

    // Copy and copy-assignment operators should never be invoked
    // for this type
    GlobalAllocLock(const GlobalAllocLock&) = delete;
    GlobalAllocLock& operator=(const GlobalAllocLock&) = delete;

    // Acquires the lock, spinning if necessary to do so. When this method
    // returns, m_lock will be zero and the lock will be acquired.
    void Acquire()
    {
        CONTRACTL {
            NOTHROW;
            GC_TRIGGERS; // switch to preemptive mode
            MODE_COOPERATIVE;
        } CONTRACTL_END;

        DWORD spinCount = 0;
        while(FastInterlockExchange(&m_lock, 0) != -1)
        {
            GCX_PREEMP();
            __SwitchToThread(0, spinCount++);
        }

        assert(m_lock == 0);
    }

    // Releases the lock.
    void Release()
    {
        LIMITED_METHOD_CONTRACT;

        // the lock may not be exactly 0. This is because the
        // assembly alloc routines increment the lock variable and
        // jump if not zero to the slow alloc path, which eventually
        // will try to acquire the lock again. At that point, it will
        // spin in Acquire (since m_lock is some number that's not zero).
        // When the thread that /does/ hold the lock releases it, the spinning
        // thread will continue.
        MemoryBarrier();
        assert(m_lock >= 0);
        m_lock = -1;
    }

    // Static helper to acquire a lock, for use with the Holder template.
    static void AcquireLock(GlobalAllocLock *lock)
    {
        WRAPPER_NO_CONTRACT;
        lock->Acquire();
    }

    // Static helper to release a lock, for use with the Holder template
    static void ReleaseLock(GlobalAllocLock *lock)
    {
        WRAPPER_NO_CONTRACT;
        lock->Release();
    }

    typedef Holder<GlobalAllocLock *, GlobalAllocLock::AcquireLock, GlobalAllocLock::ReleaseLock> Holder;
};

```
è²Œä¼¼æ˜¯ä¸ªè‡ªæ—‹é”ã€‚

[CoreCLR åˆ†é…å°å¯¹è±¡å†…å­˜-CSDNåšå®¢](https://blog.csdn.net/kidwr/article/details/142578644)
## 12 æ ¹ä¸€å®šæ˜¯å¼•ç”¨ç±»å‹å—ï¼Œæ ˆä¸Šçš„å€¼ç±»å‹æœ‰å¯èƒ½ä½œä¸ºæ ¹å—

å€¼ç±»å‹ä¸­å¦‚æœæœ‰å¼•ç”¨ç±»å‹å­—æ®µï¼Œä¼šè¢«å½“ä½œæ ¹ã€‚
jitç¼–è¯‘å™¨æœ‰æ‰§è¡Œç¯å¢ƒçš„ä¸Šä¸‹æ–‡ï¼Œå¯ä»¥å†³å®šå“ªäº›éœ€è¦ä½œä¸ºæ ¹ï¼Œåœ¨å“ªé‡Œå¯ä»¥è¿›è¡ŒGC

## 13 å“ªäº›ä¸œè¥¿ä¼šä½œä¸ºæ´»åŠ¨æ ¹

- é™æ€å˜é‡
- æ ˆä¸Šçš„å¼•ç”¨
- GCå¥æŸ„è¡¨é‡Œçš„ normal pined å¯¹è±¡
- freachableé˜Ÿåˆ—
- å­—ç¬¦ä¸²ç•™ç”¨æ± 

## 14 GCåˆ†ä»£ ä¸­ 2ä»£ã€1ä»£å¯¹è±¡ä¿®æ”¹å­—æ®µå¼•ç”¨ï¼Œå¦‚ä½•çŸ¥é“ä¿®æ”¹äº†

å¼•ç”¨ä¹¦ä¸Šå†…å®¹ï¼š

> å½“ JIT ç¼–è¯‘å™¨ç”Ÿæˆæœ¬æœº(native)ä»£ç æ¥ä¿®æ”¹å¯¹è±¡ä¸­çš„ä¸€ä¸ªå¼•ç”¨å­—æ®µæ—¶ï¼Œæœ¬æœºä»£ç ä¼šç”Ÿæˆå¯¹ä¸€ä¸ª write barrier æ–¹æ³•çš„è°ƒç”¨(è¯‘æ³¨ï¼šwrite barrier æ–¹æ³•æ˜¯åœ¨æœ‰æ•°æ®å‘å¯¹è±¡å†™å…¥æ—¶æ‰§è¡Œä¸€äº›å†…å­˜ç®¡ç†ä»£ç çš„æœºåˆ¶)ã€‚
>
> è¿™ä¸ª write barrier æ–¹æ³•æ£€æŸ¥å­—æ®µè¢«ä¿®æ”¹çš„é‚£ä¸ªå¯¹è±¡æ˜¯å¦åœ¨ç¬¬ 1 ä»£æˆ–ç¬¬ 2 ä»£ä¸­ï¼Œ
> å¦‚æœåœ¨ï¼Œwrite barrier ä»£ç å°±åœ¨ä¸€ä¸ªæ‰€è°“çš„ code table ä¸­è®¾ç½®ä¸€ä¸ª bitã€‚card table ä¸ºå †ä¸­çš„æ¯ 128 å­—èŠ‚çš„æ•°æ®éƒ½å‡†å¤‡å¥½äº†ä¸€ä¸ª bitã€‚GC ä¸‹ä¸€æ¬¡å¯åŠ¨æ—¶ä¼šæ‰«æ card tableï¼Œäº†è§£ç¬¬ 1 ä»£å’Œç¬¬ 2 ä»£ä¸­çš„å“ªäº›å¯¹è±¡çš„å­—æ®µè‡ªä¸Šæ¬¡ GC ä»¥æ¥å·²è¢«ä¿®æ”¹ã€‚
>
> ä»»ä½•è¢«ä¿®æ”¹çš„å¯¹è±¡å¼•ç”¨äº†ç¬¬ 0 ä»£ä¸­çš„ä¸€ä¸ªå¯¹è±¡ï¼Œè¢«å¼•ç”¨çš„ç¬¬ 0 ä»£å¯¹è±¡å°±ä¼šåœ¨åƒåœ¾å›æ”¶è¿‡ç¨‹ä¸­â€œå­˜æ´»â€ã€‚
>
> GC ä¹‹åï¼Œcard table ä¸­çš„æ‰€æœ‰ bit éƒ½è¢«é‡ç½®ä¸º 0ã€‚
>
> å‘å¯¹è±¡çš„å¼•ç”¨å­—æ®µä¸­å†™å…¥æ—¶ï¼Œwrite barrier ä»£ç ä¼šé€ æˆå°‘é‡æ€§èƒ½æŸå¤±(å¯¹åº”åœ°ï¼Œå‘å±€éƒ¨å˜é‡æˆ–é™æ€å­—æ®µå†™å…¥ä¾¿ä¸ä¼šæœ‰è¿™ä¸ªæŸå¤±)ã€‚å¦å¤–ï¼Œå¦‚æœå¯¹è±¡åœ¨ç¬¬ 1 ä»£æˆ–ç¬¬ 2 ä»£ä¸­ï¼Œæ€§èƒ½ä¼šæŸå¤±å¾—ç¨å¾®å¤šä¸€äº›ã€‚

é€»è¾‘ä¸Šè®²ï¼Œä¸€è½®GCè¿‡åï¼Œ1ä»£åŠä»¥ä¸Šå¯¹è±¡å¼•ç”¨çš„å¼•ç”¨å­—æ®µä¹Ÿå¿…ç„¶æ˜¯1ä»£åŠä»¥ä¸Šçš„ã€‚æˆ‘ä»¬å°±ä¸å…³å¿ƒåˆ™ä»–ä»¬é‡Œé¢å­—æ®µåŸæ¥å¼•ç”¨çš„å¯¹è±¡ã€‚

ä¹‹åæ–°ä¿®æ”¹çš„å¼•ç”¨å°±æŒ‰ç…§ä¸Šé¢æŒ‰å—æ ‡è®°çš„é€»è¾‘è¿›è¡Œå¤„ç†ã€‚

## 15. 1ä»£ 0ä»£å†…å­˜ä¸Šæ˜¯è¿ç»­çš„å—ï¼Ÿ 1ä»£ 0ä»£ æ˜¯æ€ä¹ˆæ ·æ ‡è®°çš„ï¼Œè°æ ‡è®°çš„ï¼Œåœ¨å“ªï¼Ÿï¼Œ0ä»£å’Œ1ä»£çš„å†…å­˜è¾¹ç•Œæ˜¯ä»€ä¹ˆ


```cpp
// group the frequently used ones together (need intrumentation on accessors)
class generation
{
public:
    // Don't move these first two fields without adjusting the references
    // from the __asm in jitinterface.cpp.
    alloc_context   allocation_context;
    PTR_heap_segment start_segment;
#ifndef USE_REGIONS
    uint8_t*        allocation_start;
#endif //!USE_REGIONS
    heap_segment*   allocation_segment;
    uint8_t*        allocation_context_start_region;
#ifdef USE_REGIONS
    heap_segment*   tail_region;
    heap_segment*   plan_start_segment;
    // only max_generation could have ro regions; for other generations 
    // this will be 0.
    heap_segment*   tail_ro_region;
#endif //USE_REGIONS
    allocator       free_list_allocator;
    size_t          free_list_allocated;
    size_t          end_seg_allocated;
    BOOL            allocate_end_seg_p;
    size_t          condemned_allocated;
    size_t          sweep_allocated;
    size_t          free_list_space;
    size_t          free_obj_space;
    size_t          allocation_size;
#ifndef USE_REGIONS
    uint8_t*        plan_allocation_start;
    size_t          plan_allocation_start_size;
#endif //!USE_REGIONS

    // this is the pinned plugs that got allocated into this gen.
    size_t          pinned_allocated;
    size_t          pinned_allocation_compact_size;
    size_t          pinned_allocation_sweep_size;
    int             gen_num;

#ifdef DOUBLY_LINKED_FL
    BOOL            set_bgc_mark_bit_p;
    uint8_t*        last_free_list_allocated;
#endif //DOUBLY_LINKED_FL

#ifdef FREE_USAGE_STATS
    size_t          gen_free_spaces[NUM_GEN_POWER2];
    // these are non pinned plugs only
    size_t          gen_plugs[NUM_GEN_POWER2];
    size_t          gen_current_pinned_free_spaces[NUM_GEN_POWER2];
    size_t          pinned_free_obj_space;
    // this is what got allocated into the pinned free spaces.
    size_t          allocated_in_pinned_free;
    size_t          allocated_since_last_pin;
#endif //FREE_USAGE_STATS
};
```

generationç±» å‚¨å­˜å„ä¸ªä»£çš„ä¿¡æ¯, ä¾‹å¦‚åœ°å€èŒƒå›´å’Œä½¿ç”¨çš„æ®µã€‚

è·³è½¬allocation_startçš„å€¼ï¼Œå°±å¯ä»¥å¿«é€Ÿè°ƒæ•´å¯¹è±¡çš„ä»£ã€‚

å¦‚æœGCå¯¹çŸ­æš‚å †æ®µï¼ˆå­˜å‚¨0ï¼Œ1çš„å †æ®µï¼‰è¿›è¡Œæ¸…æ‰«ï¼Œå­˜æ´»ä¸‹æ¥çš„å¯¹è±¡ä¼šå˜ä¸ºä¸‹ä¸€ä»£çš„å¯¹è±¡ï¼Œä»£çš„allocation_startä¹Ÿä¼šéšä¹‹è°ƒæ•´

> å¼•ç”¨å®˜æ–¹æ–‡æ¡£ [Windows ä¸Šçš„å¤§å‹å¯¹è±¡å † (LOH) - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/garbage-collection/large-object-heap)
> åƒåœ¾å›æ”¶å™¨æ˜¯åˆ†ä»£å›æ”¶å™¨ã€‚ å®ƒåŒ…å«ä¸‰ä»£ï¼šç¬¬ 0 ä»£ã€ç¬¬ 1 ä»£å’Œç¬¬ 2 ä»£ã€‚ åŒ…å« 3 ä»£çš„åŸå› æ˜¯ï¼Œåœ¨ä¼˜åŒ–è‰¯å¥½çš„åº”ç”¨ä¸­ï¼Œå¤§éƒ¨åˆ†å¯¹è±¡éƒ½åœ¨ç¬¬ 0 ä»£å°±æ¸…é™¤äº†ã€‚ ä¾‹å¦‚ï¼Œåœ¨æœåŠ¡å™¨åº”ç”¨ä¸­ï¼Œä¸æ¯ä¸ªè¯·æ±‚ç›¸å…³çš„åˆ†é…åº”åœ¨è¯·æ±‚å®Œæˆåæ¸…é™¤ã€‚ ä»å­˜åœ¨çš„åˆ†é…è¯·æ±‚å°†è½¬åˆ°ç¬¬ 1 ä»£ï¼Œå¹¶åœ¨é‚£é‡Œè¿›è¡Œæ¸…é™¤ã€‚ ä»æœ¬è´¨ä¸Šè®²ï¼Œç¬¬ 1 ä»£æ˜¯æ–°å¯¹è±¡åŒºåŸŸä¸ç”Ÿå­˜æœŸè¾ƒé•¿çš„å¯¹è±¡åŒºåŸŸä¹‹é—´çš„ç¼“å†²åŒºã€‚
>
> æ–°åˆ†é…çš„å¯¹è±¡æ„æˆæ–°ä¸€ä»£å¯¹è±¡ï¼Œå¹¶éšå¼åœ°æˆä¸ºç¬¬ 0 ä»£é›†åˆã€‚ ä½†æ˜¯ï¼Œå¦‚æœå®ƒä»¬æ˜¯å¤§å‹å¯¹è±¡ï¼Œå®ƒä»¬å°†å»¶ç»­åˆ°å¤§å‹å¯¹è±¡å † (LOH)ï¼Œè¿™æœ‰æ—¶ç§°ä¸ºç¬¬ 3 ä»£ã€‚ ç¬¬ 3 ä»£æ˜¯åœ¨ç¬¬ 2 ä»£ä¸­é€»è¾‘æ”¶é›†çš„ç‰©ç†ç”Ÿæˆã€‚
>
> å¤§å‹å¯¹è±¡å±äºç¬¬ 2 ä»£ï¼Œå› ä¸ºåªæœ‰åœ¨ç¬¬ 2 ä»£å›æ”¶æœŸé—´æ‰èƒ½å›æ”¶å®ƒä»¬ã€‚ å›æ”¶ä¸€ä»£æ—¶ï¼ŒåŒæ—¶ä¹Ÿä¼šå›æ”¶å®ƒå‰é¢çš„æ‰€æœ‰ä»£ã€‚ ä¾‹å¦‚ï¼Œæ‰§è¡Œç¬¬ 1 ä»£ GC æ—¶ï¼Œå°†åŒæ—¶å›æ”¶ç¬¬ 1 ä»£å’Œç¬¬ 0 ä»£ã€‚ æ‰§è¡Œç¬¬ 2 ä»£ GC æ—¶ï¼Œå°†å›æ”¶æ•´ä¸ªå †ã€‚ å› æ­¤ï¼Œç¬¬ 2 ä»£ GC è¿˜å¯ç§°ä¸ºâ€œå®Œæ•´ GCâ€ã€‚ æœ¬æ–‡å¼•ç”¨ç¬¬ 2 ä»£ GC è€Œä¸æ˜¯å®Œæ•´ GCï¼Œä½†è¿™ä¸¤ä¸ªæœ¯è¯­æ˜¯å¯ä»¥äº’æ¢çš„ã€‚
>
> ä»£å¯æä¾› GC å †çš„é€»è¾‘è§†å›¾ã€‚ å®é™…ä¸Šï¼Œå¯¹è±¡å­˜åœ¨äºæ‰˜ç®¡å †æ®µä¸­ã€‚ æ‰˜ç®¡å †æ®µæ˜¯ GC é€šè¿‡è°ƒç”¨Â [VirtualAlloc åŠŸèƒ½](https://learn.microsoft.com/zh-cn/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)ä»£è¡¨æ‰˜ç®¡ä»£ç åœ¨æ“ä½œç³»ç»Ÿä¸Šä¿ç•™çš„å†…å­˜å—ã€‚ åŠ è½½ CLR æ—¶ï¼ŒGC åˆ†é…ä¸¤ä¸ªåˆå§‹å †æ®µï¼šä¸€ä¸ªç”¨äºå°å‹å¯¹è±¡ï¼ˆå°å‹å¯¹è±¡å †æˆ– SOHï¼‰ï¼Œä¸€ä¸ªç”¨äºå¤§å‹å¯¹è±¡ï¼ˆå¤§å‹å¯¹è±¡å †ï¼‰ã€‚


[CoreCLRæºç æ¢ç´¢(äºŒ) newæ˜¯ä»€ä¹ˆ - q303248153 - åšå®¢å›­](https://www.cnblogs.com/zkweb/p/6266117.html)
[CoreCLRæºç æ¢ç´¢(ä¸‰) GCå†…å­˜åˆ†é…å™¨çš„å†…éƒ¨å®ç° - q303248153 - åšå®¢å›­](https://www.cnblogs.com/zkweb/p/6379080.html)