以下是访问一个资源所需的步骤。
1. 调用 IL 执行 newobj，为代表资源的类型分配内存(一般使用 C# `new` 操作符来完成)。
2. 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。
3. 访问类型的成员来使用资源(有必要可以重复)。
4. 摧毁资源的状态以进行清理。
5. 释放内存。垃圾回收器独自负责这一步。


C# 的 `new` 操作符导致 CLR 执行以下步骤。
1. 计算类型的字段(以及从基类型继承的字段)所需的字节数。
2. 加上对象的开销所需的字节数。每个对象都有两个开销字段：类型对象指针和同步块索引。对于 32 位应用程序，这两个字段各自需要 32 位，所以每个对象要增加 8 字节。对于 64 位应用程序，这两个字段各自需要 64 位，所以每个对象要增加 16 字节。
3. CLR 检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在 `NextObjPtr` 指针指向的地址处放入对象，为对象分配的字节会被清零。接着调用类型的构造器(为 `this` 参数传递 `NextObjPtr`)，`new` 操作符返回对象引用。就在返回这个引用之前， `NextObjPtr` 指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。


CLR 的 GC 是**基于代的垃圾回收器**(generational garbage collector)，它对你的代码做出了以下几点假设。
* 对象越新，生存期越短。
* 对象越老，生存期越长。
* 回收堆的一部分，速度快于回收整个堆。


前面说过，CLR 在检测第 0 代超过预算时触发一次 GC。这是 GC 最常见的触发条件，下面列出其他条件。
* **代码显式调用`System.GC`的静态 `Collect`方法**  
  代码可显式请求 CLR 执行回收。虽然 Microsoft 强烈反对这种请求，但有时情势比人强。详情参见本章稍后的 21.2.4 节“强制垃圾回收”。
* **Windows报告低内存情况**  
  CLR 内部使用 Win32 函数 `CreateMemoryResourceNotification` 和 `QueryMemoryResourceNotification` 监视系统的总体内存使用情况。如果 Windows 报告低内存，CLR 将强制垃圾回收以释放死对象，减小进程工作集。
* **CLR 正在卸载 AppDomain**  
  一个 AppDomain 卸载时，CLR 认为其中一切都不是根，所以执行涵盖所有代的垃圾回收。AppDomain 将在第 22 章讨论。
* **CLR 正在关闭**  
  CLR 在进程正常终止<sup>①</sup>时关闭。关闭期间，CLR 认为进程中一切都不是根。对象有机会进行资源清理，但 CLR 不会试图压缩或释放内存。整个进程都要终止了， Windows 将回收进程的全部内存。

大对象
还有另一个性能提升举措值得注意。CLR 将对象分为大对象和小对象。本章到目前为止说的都是小对象。目前认为 85000 字节或更大的对象是大对象。CLR 以不同方式对待大小对象。
* 大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配。
* 目前版本的 GC 不压缩大对象，因为在内存中移动它们代价过高。但这可能在进程中的大对象之间造成地址空间的碎片化，以至于抛出 `OutOfMemoryException`。CLR 将来的版本可能压缩大对象。
* 大对象总是第 2 代，绝不可能是第 0 代或 第 1 代。所以只能为需要长时间存活的资源创建大对象。分配短时间存活的大对象。分配短时间存活的大对象会导致第 2 代被更频繁地回收，会损害性能。大对象一般是大字符串(比如 XML 或 JSON)或者用于 I/O 操作的字节数组(比如从文件或网络将字节读入缓冲区以便处理)。


CLR 启动时会选择一个 GC 模式，进程终止前该模式不会改变。有两个基本 GC 模式。
* **工作站**  
  该模式针对客户端应用程序优化 GC。GC 造成的延时很低，应用程序线程挂起时间很短，避免使用户感到焦虑。在该模式中，GC 假定机器上运行的其他应用程序都不会消耗太多的 CPU 资源。
* **服务器**  
  该模式针对服务器端应用程序优化 GC。被优化的主要是吞吐量和资源利用。GC 假定机器上没有运行其他应用程序(无论客户端还是服务器应用程序)，并假定机器的所有 CPU 都可用来辅助完成 GC。该模式造成托管堆被拆分成几个区域(section)，每个 CPU 一个。开始垃圾回收时，垃圾回收器在每个 CPU 上都运行一个特殊线程：每个线程都和其他线程并发回收它自己的区域。对于工作者线程(worker thread)行为一致的服务器应用程序，并发回收能很好地进行。这个功能要求应用程序在多 CPU 计算机上运行，使线程能正真地同时工作，从而获得性能的提升。


除了这两种主要模式，GC 还支持两种子模式：并发(默认)或非并发。在并发方式中，垃圾回收器有一个额外的后台线程，它能在应用程序运行时并发标记对象。一个线程因为分配对象造成第 0 代超出预算时，GC 首先挂起所有线程，再判断要回收哪些代。如果要回收第 0 代或第 1 代，那么一切如常进行。但是，如果要回收第 2 代，就会增大第 0 代的大小(超过其预算)，以便在第 0 代中分配新对象。然后，应用程序的线程恢复运行。

|             符号名称             |                                                          说明                                                           |
| :--------------------------: | :-------------------------------------------------------------------------------------------------------------------: |
|   `Batch`("服务器" GC 模式的默认值)   |                                                        关闭并发 GC                                                        |
| `Interactive`(“工作站”GC模式的默认值) |                                                        打开并发 GC                                                        |
|         `LowLatency`         |                                    在短期的、时间敏感的操作中(比如动画绘制)使用这个延迟模式。这些操作不适合对第 2 代进行回收                                    |
|    `SustainedLowLatency`     | 使用这个延迟模式，应用程序的大多数操作都不会发生长的 GC 暂停。只要有足够内存，它将禁止所有会造成阻塞的第 2 代回收动作。事实上，这种应用程序(例如需要迅速响应的股票软件)的用户应考虑安装更多的 RAM 来防止发生长的 GC 暂停 |


表 21-2 `GCCollectionMode`枚举类型定义的符号

|符号名称|说明|
|:---:|:---:|
|`Default`|等同于不传递任何符号名称。目前还等同于传递 `Forced`，但 CLR 未来的版本可能对此进行修改|
|`Forced`|强制回收指定的代(以及低于它的所有代)|
|`Optimized`|只有在能释放大量内存或者能减少碎片化的前提下，才执行回收。如果垃圾回收没有什么效率，当前调用就没有任何效果|

